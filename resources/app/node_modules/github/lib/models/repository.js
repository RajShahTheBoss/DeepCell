'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CommitError = exports.AbortMergeError = undefined;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _eventKit = require('event-kit');

var _compositeGitStrategy = require('../composite-git-strategy');

var _compositeGitStrategy2 = _interopRequireDefault(_compositeGitStrategy);

var _helpers = require('../helpers');

var _remote = require('./remote');

var _remote2 = _interopRequireDefault(_remote);

var _repositoryStates = require('./repository-states');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const MERGE_MARKER_REGEX = /^(>|<){7} \S+$/m;

// Internal option keys used to designate the desired initial state of a Repository.
const initialStateSym = Symbol('initialState');

let AbortMergeError = exports.AbortMergeError = class AbortMergeError extends Error {
  constructor(code, filePath) {
    super();
    this.message = `${code}: ${filePath}.`;
    this.code = code;
    this.path = filePath;
    this.stack = new Error().stack;
  }
};
let CommitError = exports.CommitError = class CommitError extends Error {
  constructor(code) {
    super();
    this.message = `Commit error: ${code}.`;
    this.code = code;
    this.stack = new Error().stack;
  }
};
let Repository = class Repository {
  constructor(workingDirectoryPath) {
    let gitStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    this.workingDirectoryPath = workingDirectoryPath;
    this.git = gitStrategy || _compositeGitStrategy2.default.create(workingDirectoryPath);

    this.emitter = new _eventKit.Emitter();

    this.loadPromise = new Promise(resolve => {
      const sub = this.onDidChangeState(() => {
        if (!this.isLoading()) {
          resolve();
          sub.dispose();
        } else if (this.isDestroyed()) {
          sub.dispose();
        }
      });
    });

    this.transitionTo(options[initialStateSym] || _repositoryStates.Loading);
  }

  static absent() {
    return new Repository(null, null, { [initialStateSym]: _repositoryStates.Absent });
  }

  static loadingGuess() {
    return new Repository(null, null, { [initialStateSym]: _repositoryStates.LoadingGuess });
  }

  static absentGuess() {
    return new Repository(null, null, { [initialStateSym]: _repositoryStates.AbsentGuess });
  }

  // State management //////////////////////////////////////////////////////////////////////////////////////////////////

  transition(currentState, StateConstructor) {
    if (currentState !== this.state) {
      // Attempted transition from a non-active state, most likely from an asynchronous start() method.
      return Promise.resolve();
    }

    for (var _len = arguments.length, payload = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      payload[_key - 2] = arguments[_key];
    }

    const nextState = new StateConstructor(this, ...payload);
    this.state = nextState;

    this.emitter.emit('did-change-state', { from: currentState, to: this.state });
    if (!this.isDestroyed()) {
      this.emitter.emit('did-update');
    }

    return this.state.start();
  }

  transitionTo(StateConstructor) {
    for (var _len2 = arguments.length, payload = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      payload[_key2 - 1] = arguments[_key2];
    }

    return this.transition(this.state, StateConstructor, ...payload);
  }

  getLoadPromise() {
    return this.isAbsent() ? Promise.reject(new Error('An absent repository will never load')) : this.loadPromise;
  }

  /*
   * Use `callback` to request user input from all git strategies.
   */
  setPromptCallback(callback) {
    this.git.getImplementers().forEach(strategy => strategy.setPromptCallback(callback));
  }

  // Event subscription ////////////////////////////////////////////////////////////////////////////////////////////////

  onDidDestroy(callback) {
    return this.emitter.on('did-destroy', callback);
  }

  onDidChangeState(callback) {
    return this.emitter.on('did-change-state', callback);
  }

  onDidUpdate(callback) {
    return this.emitter.on('did-update', callback);
  }

  // State-independent actions /////////////////////////////////////////////////////////////////////////////////////////
  // Actions that use direct filesystem access or otherwise don't need `this.git` to be available.

  pathHasMergeMarkers(relativePath) {
    var _this = this;

    return _asyncToGenerator(function* () {
      try {
        const contents = yield (0, _helpers.readFile)(_path2.default.join(_this.getWorkingDirectoryPath(), relativePath), 'utf8');
        return MERGE_MARKER_REGEX.test(contents);
      } catch (e) {
        // EISDIR implies this is a submodule
        if (e.code === 'ENOENT' || e.code === 'EISDIR') {
          return false;
        } else {
          throw e;
        }
      }
    })();
  }

  getMergeMessage() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      try {
        const contents = yield (0, _helpers.readFile)(_path2.default.join(_this2.getGitDirectoryPath(), 'MERGE_MSG'), 'utf8');
        return contents;
      } catch (e) {
        return null;
      }
    })();
  }

  // State-independent accessors ///////////////////////////////////////////////////////////////////////////////////////

  getWorkingDirectoryPath() {
    return this.workingDirectoryPath;
  }

  setGitDirectoryPath(gitDirectoryPath) {
    this._gitDirectoryPath = gitDirectoryPath;
  }

  getGitDirectoryPath() {
    if (this._gitDirectoryPath) {
      return this._gitDirectoryPath;
    } else {
      return _path2.default.join(this.getWorkingDirectoryPath(), '.git');
    }
  }

  isInState(stateName) {
    return this.state.constructor.name === stateName;
  }

  toString() {
    return `Repository(state=${this.state.constructor.name}, workdir="${this.getWorkingDirectoryPath()}")`;
  }

  // Compound Getters //////////////////////////////////////////////////////////////////////////////////////////////////
  // Accessor methods for data derived from other, state-provided getters.

  getUnstagedChanges() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      var _ref = yield _this3.getStatusBundle();

      const unstagedFiles = _ref.unstagedFiles;

      return Object.keys(unstagedFiles).map(function (filePath) {
        return { filePath, status: unstagedFiles[filePath] };
      });
    })();
  }

  getStagedChanges() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      var _ref2 = yield _this4.getStatusBundle();

      const stagedFiles = _ref2.stagedFiles;

      return Object.keys(stagedFiles).map(function (filePath) {
        return { filePath, status: stagedFiles[filePath] };
      });
    })();
  }

  getMergeConflicts() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      var _ref3 = yield _this5.getStatusBundle();

      const mergeConflictFiles = _ref3.mergeConflictFiles;

      return Object.keys(mergeConflictFiles).map(function (filePath) {
        return { filePath, status: mergeConflictFiles[filePath] };
      });
    })();
  }

  isPartiallyStaged(fileName) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      var _ref4 = yield _this6.getStatusBundle();

      const unstagedFiles = _ref4.unstagedFiles,
            stagedFiles = _ref4.stagedFiles;

      const u = unstagedFiles[fileName];
      const s = stagedFiles[fileName];
      return u === 'modified' && s === 'modified' || u === 'modified' && s === 'added' || u === 'added' && s === 'deleted' || u === 'deleted' && s === 'modified';
    })();
  }

  getRemoteForBranch(branchName) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      const name = yield _this7.getConfig(`branch.${branchName}.remote`);
      if (name === null) {
        return _remote.nullRemote;
      } else {
        return new _remote2.default(name);
      }
    })();
  }

  saveDiscardHistory() {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      if (_this8.isDestroyed()) {
        return;
      }

      const historySha = yield _this8.createDiscardHistoryBlob();
      if (_this8.isDestroyed()) {
        return;
      }
      yield _this8.setConfig('atomGithub.historySha', historySha);
    })();
  }
};

// The methods named here will be delegated to the current State.
//
// This list should match the methods decorated with @shouldDelegate in `lib/models/repository-states/state.js`. A test
// case in `test/models/repository.test.js` ensures that these sets match.
//
// Duplicated here rather than just using `expectedDelegates` directly so that this file is grep-friendly for answering
// the question of "what all can a Repository do exactly".

exports.default = Repository;
const delegates = ['isLoadingGuess', 'isAbsentGuess', 'isAbsent', 'isLoading', 'isEmpty', 'isPresent', 'isDestroyed', 'isUndetermined', 'showGitTabInit', 'showGitTabInitInProgress', 'showGitTabLoading', 'showStatusBarTiles', 'hasDirectory', 'init', 'clone', 'destroy', 'refresh', 'observeFilesystemChange', 'stageFiles', 'unstageFiles', 'stageFilesFromParentCommit', 'applyPatchToIndex', 'applyPatchToWorkdir', 'commit', 'merge', 'abortMerge', 'checkoutSide', 'mergeFile', 'writeMergeConflictToIndex', 'checkout', 'checkoutPathsAtRevision', 'fetch', 'pull', 'push', 'setConfig', 'createBlob', 'expandBlobToFile', 'createDiscardHistoryBlob', 'updateDiscardHistory', 'storeBeforeAndAfterBlobs', 'restoreLastDiscardInTempFiles', 'popDiscardHistory', 'clearDiscardHistory', 'discardWorkDirChangesForPaths', 'getStatusBundle', 'getStatusesForChangedFiles', 'getStagedChangesSinceParentCommit', 'getFilePatchForPath', 'readFileFromIndex', 'getLastCommit', 'getBranches', 'getCurrentBranch', 'isMerging', 'isRebasing', 'getRemotes', 'getAheadCount', 'getBehindCount', 'getConfig', 'unsetConfig', 'getBlobContents', 'hasDiscardHistory', 'getDiscardHistory', 'getLastHistorySnapshots'];

for (let i = 0; i < delegates.length; i++) {
  const delegate = delegates[i];

  Repository.prototype[delegate] = function () {
    return this.state[delegate](...arguments);
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcG9zaXRvcnkuanMiXSwibmFtZXMiOlsiTUVSR0VfTUFSS0VSX1JFR0VYIiwiaW5pdGlhbFN0YXRlU3ltIiwiU3ltYm9sIiwiQWJvcnRNZXJnZUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJmaWxlUGF0aCIsIm1lc3NhZ2UiLCJwYXRoIiwic3RhY2siLCJDb21taXRFcnJvciIsIlJlcG9zaXRvcnkiLCJ3b3JraW5nRGlyZWN0b3J5UGF0aCIsImdpdFN0cmF0ZWd5Iiwib3B0aW9ucyIsImdpdCIsImNyZWF0ZSIsImVtaXR0ZXIiLCJsb2FkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic3ViIiwib25EaWRDaGFuZ2VTdGF0ZSIsImlzTG9hZGluZyIsImRpc3Bvc2UiLCJpc0Rlc3Ryb3llZCIsInRyYW5zaXRpb25UbyIsImFic2VudCIsImxvYWRpbmdHdWVzcyIsImFic2VudEd1ZXNzIiwidHJhbnNpdGlvbiIsImN1cnJlbnRTdGF0ZSIsIlN0YXRlQ29uc3RydWN0b3IiLCJzdGF0ZSIsInBheWxvYWQiLCJuZXh0U3RhdGUiLCJlbWl0IiwiZnJvbSIsInRvIiwic3RhcnQiLCJnZXRMb2FkUHJvbWlzZSIsImlzQWJzZW50IiwicmVqZWN0Iiwic2V0UHJvbXB0Q2FsbGJhY2siLCJjYWxsYmFjayIsImdldEltcGxlbWVudGVycyIsImZvckVhY2giLCJzdHJhdGVneSIsIm9uRGlkRGVzdHJveSIsIm9uIiwib25EaWRVcGRhdGUiLCJwYXRoSGFzTWVyZ2VNYXJrZXJzIiwicmVsYXRpdmVQYXRoIiwiY29udGVudHMiLCJqb2luIiwiZ2V0V29ya2luZ0RpcmVjdG9yeVBhdGgiLCJ0ZXN0IiwiZSIsImdldE1lcmdlTWVzc2FnZSIsImdldEdpdERpcmVjdG9yeVBhdGgiLCJzZXRHaXREaXJlY3RvcnlQYXRoIiwiZ2l0RGlyZWN0b3J5UGF0aCIsIl9naXREaXJlY3RvcnlQYXRoIiwiaXNJblN0YXRlIiwic3RhdGVOYW1lIiwibmFtZSIsInRvU3RyaW5nIiwiZ2V0VW5zdGFnZWRDaGFuZ2VzIiwiZ2V0U3RhdHVzQnVuZGxlIiwidW5zdGFnZWRGaWxlcyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJzdGF0dXMiLCJnZXRTdGFnZWRDaGFuZ2VzIiwic3RhZ2VkRmlsZXMiLCJnZXRNZXJnZUNvbmZsaWN0cyIsIm1lcmdlQ29uZmxpY3RGaWxlcyIsImlzUGFydGlhbGx5U3RhZ2VkIiwiZmlsZU5hbWUiLCJ1IiwicyIsImdldFJlbW90ZUZvckJyYW5jaCIsImJyYW5jaE5hbWUiLCJnZXRDb25maWciLCJzYXZlRGlzY2FyZEhpc3RvcnkiLCJoaXN0b3J5U2hhIiwiY3JlYXRlRGlzY2FyZEhpc3RvcnlCbG9iIiwic2V0Q29uZmlnIiwiZGVsZWdhdGVzIiwiaSIsImxlbmd0aCIsImRlbGVnYXRlIiwicHJvdG90eXBlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7QUFFQTs7QUFFQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLHFCQUFxQixpQkFBM0I7O0FBRUE7QUFDQSxNQUFNQyxrQkFBa0JDLE9BQU8sY0FBUCxDQUF4Qjs7SUFFYUMsZSxXQUFBQSxlLEdBQU4sTUFBTUEsZUFBTixTQUE4QkMsS0FBOUIsQ0FBb0M7QUFDekNDLGNBQVlDLElBQVosRUFBa0JDLFFBQWxCLEVBQTRCO0FBQzFCO0FBQ0EsU0FBS0MsT0FBTCxHQUFnQixHQUFFRixJQUFLLEtBQUlDLFFBQVMsR0FBcEM7QUFDQSxTQUFLRCxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLRyxJQUFMLEdBQVlGLFFBQVo7QUFDQSxTQUFLRyxLQUFMLEdBQWEsSUFBSU4sS0FBSixHQUFZTSxLQUF6QjtBQUNEO0FBUHdDLEM7SUFVOUJDLFcsV0FBQUEsVyxHQUFOLE1BQU1BLFdBQU4sU0FBMEJQLEtBQTFCLENBQWdDO0FBQ3JDQyxjQUFZQyxJQUFaLEVBQWtCO0FBQ2hCO0FBQ0EsU0FBS0UsT0FBTCxHQUFnQixpQkFBZ0JGLElBQUssR0FBckM7QUFDQSxTQUFLQSxJQUFM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aEIscUJBM0RnQixFQTREaEIsbUJBNURnQixFQThEaEIsZUE5RGdCLEVBZ0VoQixhQWhFZ0IsRUFpRWhCLGtCQWpFZ0IsRUFtRWhCLFdBbkVnQixFQW9FaEIsWUFwRWdCLEVBc0VoQixZQXRFZ0IsRUF3RWhCLGVBeEVnQixFQXlFaEIsZ0JBekVnQixFQTJFaEIsV0EzRWdCLEVBNEVoQixhQTVFZ0IsRUE4RWhCLGlCQTlFZ0IsRUFnRmhCLG1CQWhGZ0IsRUFpRmhCLG1CQWpGZ0IsRUFrRmhCLHlCQWxGZ0IsQ0FBbEI7O0FBcUZBLEtBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxVQUFVRSxNQUE5QixFQUFzQ0QsR0FBdEMsRUFBMkM7QUFDekMsUUFBTUUsV0FBV0gsVUFBVUMsQ0FBVixDQUFqQjs7QUFFQS9FLGFBQVdrRixTQUFYLENBQXFCRCxRQUFyQixJQUFpQyxZQUFrQjtBQUNqRCxXQUFPLEtBQUszRCxLQUFMLENBQVcyRCxRQUFYLEVBQXFCLFlBQXJCLENBQVA7QUFDRCxHQUZEO0FBR0QiLCJmaWxlIjoicmVwb3NpdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJDOi9wcm9qZWN0cy9hdG9tL291dC9hcHAvbm9kZV9tb2R1bGVzL2dpdGh1YiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQge0VtaXR0ZXJ9IGZyb20gJ2V2ZW50LWtpdCc7XG5cbmltcG9ydCBDb21wb3NpdGVHaXRTdHJhdGVneSBmcm9tICcuLi9jb21wb3NpdGUtZ2l0LXN0cmF0ZWd5JztcbmltcG9ydCB7cmVhZEZpbGV9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IFJlbW90ZSwge251bGxSZW1vdGV9IGZyb20gJy4vcmVtb3RlJztcbmltcG9ydCB7TG9hZGluZywgQWJzZW50LCBMb2FkaW5nR3Vlc3MsIEFic2VudEd1ZXNzfSBmcm9tICcuL3JlcG9zaXRvcnktc3RhdGVzJztcblxuY29uc3QgTUVSR0VfTUFSS0VSX1JFR0VYID0gL14oPnw8KXs3fSBcXFMrJC9tO1xuXG4vLyBJbnRlcm5hbCBvcHRpb24ga2V5cyB1c2VkIHRvIGRlc2lnbmF0ZSB0aGUgZGVzaXJlZCBpbml0aWFsIHN0YXRlIG9mIGEgUmVwb3NpdG9yeS5cbmNvbnN0IGluaXRpYWxTdGF0ZVN5bSA9IFN5bWJvbCgnaW5pdGlhbFN0YXRlJyk7XG5cbmV4cG9ydCBjbGFzcyBBYm9ydE1lcmdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIGZpbGVQYXRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgJHtjb2RlfTogJHtmaWxlUGF0aH0uYDtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMucGF0aCA9IGZpbGVQYXRoO1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29tbWl0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWVzc2FnZSA9IGBDb21taXQgZXJyb3I6ICR7Y29kZX0uYDtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXBvc2l0b3J5IHtcbiAgY29uc3RydWN0b3Iod29ya2luZ0RpcmVjdG9yeVBhdGgsIGdpdFN0cmF0ZWd5ID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy53b3JraW5nRGlyZWN0b3J5UGF0aCA9IHdvcmtpbmdEaXJlY3RvcnlQYXRoO1xuICAgIHRoaXMuZ2l0ID0gZ2l0U3RyYXRlZ3kgfHwgQ29tcG9zaXRlR2l0U3RyYXRlZ3kuY3JlYXRlKHdvcmtpbmdEaXJlY3RvcnlQYXRoKTtcblxuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cbiAgICB0aGlzLmxvYWRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBzdWIgPSB0aGlzLm9uRGlkQ2hhbmdlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2FkaW5nKCkpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgc3ViLmRpc3Bvc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRGVzdHJveWVkKCkpIHtcbiAgICAgICAgICBzdWIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKG9wdGlvbnNbaW5pdGlhbFN0YXRlU3ltXSB8fCBMb2FkaW5nKTtcbiAgfVxuXG4gIHN0YXRpYyBhYnNlbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXBvc2l0b3J5KG51bGwsIG51bGwsIHtbaW5pdGlhbFN0YXRlU3ltXTogQWJzZW50fSk7XG4gIH1cblxuICBzdGF0aWMgbG9hZGluZ0d1ZXNzKCkge1xuICAgIHJldHVybiBuZXcgUmVwb3NpdG9yeShudWxsLCBudWxsLCB7W2luaXRpYWxTdGF0ZVN5bV06IExvYWRpbmdHdWVzc30pO1xuICB9XG5cbiAgc3RhdGljIGFic2VudEd1ZXNzKCkge1xuICAgIHJldHVybiBuZXcgUmVwb3NpdG9yeShudWxsLCBudWxsLCB7W2luaXRpYWxTdGF0ZVN5bV06IEFic2VudEd1ZXNzfSk7XG4gIH1cblxuICAvLyBTdGF0ZSBtYW5hZ2VtZW50IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgdHJhbnNpdGlvbihjdXJyZW50U3RhdGUsIFN0YXRlQ29uc3RydWN0b3IsIC4uLnBheWxvYWQpIHtcbiAgICBpZiAoY3VycmVudFN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICAvLyBBdHRlbXB0ZWQgdHJhbnNpdGlvbiBmcm9tIGEgbm9uLWFjdGl2ZSBzdGF0ZSwgbW9zdCBsaWtlbHkgZnJvbSBhbiBhc3luY2hyb25vdXMgc3RhcnQoKSBtZXRob2QuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFN0YXRlID0gbmV3IFN0YXRlQ29uc3RydWN0b3IodGhpcywgLi4ucGF5bG9hZCk7XG4gICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZTtcblxuICAgIHRoaXMuZW1pdHRlci5lbWl0KCdkaWQtY2hhbmdlLXN0YXRlJywge2Zyb206IGN1cnJlbnRTdGF0ZSwgdG86IHRoaXMuc3RhdGV9KTtcbiAgICBpZiAoIXRoaXMuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoJ2RpZC11cGRhdGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGFydCgpO1xuICB9XG5cbiAgdHJhbnNpdGlvblRvKFN0YXRlQ29uc3RydWN0b3IsIC4uLnBheWxvYWQpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uKHRoaXMuc3RhdGUsIFN0YXRlQ29uc3RydWN0b3IsIC4uLnBheWxvYWQpO1xuICB9XG5cbiAgZ2V0TG9hZFByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNBYnNlbnQoKSA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQW4gYWJzZW50IHJlcG9zaXRvcnkgd2lsbCBuZXZlciBsb2FkJykpIDogdGhpcy5sb2FkUHJvbWlzZTtcbiAgfVxuXG4gIC8qXG4gICAqIFVzZSBgY2FsbGJhY2tgIHRvIHJlcXVlc3QgdXNlciBpbnB1dCBmcm9tIGFsbCBnaXQgc3RyYXRlZ2llcy5cbiAgICovXG4gIHNldFByb21wdENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5naXQuZ2V0SW1wbGVtZW50ZXJzKCkuZm9yRWFjaChzdHJhdGVneSA9PiBzdHJhdGVneS5zZXRQcm9tcHRDYWxsYmFjayhjYWxsYmFjaykpO1xuICB9XG5cbiAgLy8gRXZlbnQgc3Vic2NyaXB0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIG9uRGlkRGVzdHJveShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oJ2RpZC1kZXN0cm95JywgY2FsbGJhY2spO1xuICB9XG5cbiAgb25EaWRDaGFuZ2VTdGF0ZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oJ2RpZC1jaGFuZ2Utc3RhdGUnLCBjYWxsYmFjayk7XG4gIH1cblxuICBvbkRpZFVwZGF0ZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oJ2RpZC11cGRhdGUnLCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTdGF0ZS1pbmRlcGVuZGVudCBhY3Rpb25zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEFjdGlvbnMgdGhhdCB1c2UgZGlyZWN0IGZpbGVzeXN0ZW0gYWNjZXNzIG9yIG90aGVyd2lzZSBkb24ndCBuZWVkIGB0aGlzLmdpdGAgdG8gYmUgYXZhaWxhYmxlLlxuXG4gIGFzeW5jIHBhdGhIYXNNZXJnZU1hcmtlcnMocmVsYXRpdmVQYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgcmVhZEZpbGUocGF0aC5qb2luKHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeVBhdGgoKSwgcmVsYXRpdmVQYXRoKSwgJ3V0ZjgnKTtcbiAgICAgIHJldHVybiBNRVJHRV9NQVJLRVJfUkVHRVgudGVzdChjb250ZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gRUlTRElSIGltcGxpZXMgdGhpcyBpcyBhIHN1Ym1vZHVsZVxuICAgICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcgfHwgZS5jb2RlID09PSAnRUlTRElSJykgeyByZXR1cm4gZmFsc2U7IH0gZWxzZSB7IHRocm93IGU7IH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRNZXJnZU1lc3NhZ2UoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgcmVhZEZpbGUocGF0aC5qb2luKHRoaXMuZ2V0R2l0RGlyZWN0b3J5UGF0aCgpLCAnTUVSR0VfTVNHJyksICd1dGY4Jyk7XG4gICAgICByZXR1cm4gY29udGVudHM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGUtaW5kZXBlbmRlbnQgYWNjZXNzb3JzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGdldFdvcmtpbmdEaXJlY3RvcnlQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLndvcmtpbmdEaXJlY3RvcnlQYXRoO1xuICB9XG5cbiAgc2V0R2l0RGlyZWN0b3J5UGF0aChnaXREaXJlY3RvcnlQYXRoKSB7XG4gICAgdGhpcy5fZ2l0RGlyZWN0b3J5UGF0aCA9IGdpdERpcmVjdG9yeVBhdGg7XG4gIH1cblxuICBnZXRHaXREaXJlY3RvcnlQYXRoKCkge1xuICAgIGlmICh0aGlzLl9naXREaXJlY3RvcnlQYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2l0RGlyZWN0b3J5UGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhdGguam9pbih0aGlzLmdldFdvcmtpbmdEaXJlY3RvcnlQYXRoKCksICcuZ2l0Jyk7XG4gICAgfVxuICB9XG5cbiAgaXNJblN0YXRlKHN0YXRlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnN0cnVjdG9yLm5hbWUgPT09IHN0YXRlTmFtZTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgUmVwb3NpdG9yeShzdGF0ZT0ke3RoaXMuc3RhdGUuY29uc3RydWN0b3IubmFtZX0sIHdvcmtkaXI9XCIke3RoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeVBhdGgoKX1cIilgO1xuICB9XG5cbiAgLy8gQ29tcG91bmQgR2V0dGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBBY2Nlc3NvciBtZXRob2RzIGZvciBkYXRhIGRlcml2ZWQgZnJvbSBvdGhlciwgc3RhdGUtcHJvdmlkZWQgZ2V0dGVycy5cblxuICBhc3luYyBnZXRVbnN0YWdlZENoYW5nZXMoKSB7XG4gICAgY29uc3Qge3Vuc3RhZ2VkRmlsZXN9ID0gYXdhaXQgdGhpcy5nZXRTdGF0dXNCdW5kbGUoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModW5zdGFnZWRGaWxlcykubWFwKGZpbGVQYXRoID0+IHsgcmV0dXJuIHtmaWxlUGF0aCwgc3RhdHVzOiB1bnN0YWdlZEZpbGVzW2ZpbGVQYXRoXX07IH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0U3RhZ2VkQ2hhbmdlcygpIHtcbiAgICBjb25zdCB7c3RhZ2VkRmlsZXN9ID0gYXdhaXQgdGhpcy5nZXRTdGF0dXNCdW5kbGUoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RhZ2VkRmlsZXMpLm1hcChmaWxlUGF0aCA9PiB7IHJldHVybiB7ZmlsZVBhdGgsIHN0YXR1czogc3RhZ2VkRmlsZXNbZmlsZVBhdGhdfTsgfSk7XG4gIH1cblxuICBhc3luYyBnZXRNZXJnZUNvbmZsaWN0cygpIHtcbiAgICBjb25zdCB7bWVyZ2VDb25mbGljdEZpbGVzfSA9IGF3YWl0IHRoaXMuZ2V0U3RhdHVzQnVuZGxlKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlQ29uZmxpY3RGaWxlcykubWFwKGZpbGVQYXRoID0+IHtcbiAgICAgIHJldHVybiB7ZmlsZVBhdGgsIHN0YXR1czogbWVyZ2VDb25mbGljdEZpbGVzW2ZpbGVQYXRoXX07XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBpc1BhcnRpYWxseVN0YWdlZChmaWxlTmFtZSkge1xuICAgIGNvbnN0IHt1bnN0YWdlZEZpbGVzLCBzdGFnZWRGaWxlc30gPSBhd2FpdCB0aGlzLmdldFN0YXR1c0J1bmRsZSgpO1xuICAgIGNvbnN0IHUgPSB1bnN0YWdlZEZpbGVzW2ZpbGVOYW1lXTtcbiAgICBjb25zdCBzID0gc3RhZ2VkRmlsZXNbZmlsZU5hbWVdO1xuICAgIHJldHVybiAodSA9PT0gJ21vZGlmaWVkJyAmJiBzID09PSAnbW9kaWZpZWQnKSB8fFxuICAgICAgKHUgPT09ICdtb2RpZmllZCcgJiYgcyA9PT0gJ2FkZGVkJykgfHxcbiAgICAgICh1ID09PSAnYWRkZWQnICYmIHMgPT09ICdkZWxldGVkJykgfHxcbiAgICAgICh1ID09PSAnZGVsZXRlZCcgJiYgcyA9PT0gJ21vZGlmaWVkJyk7XG4gIH1cblxuICBhc3luYyBnZXRSZW1vdGVGb3JCcmFuY2goYnJhbmNoTmFtZSkge1xuICAgIGNvbnN0IG5hbWUgPSBhd2FpdCB0aGlzLmdldENvbmZpZyhgYnJhbmNoLiR7YnJhbmNoTmFtZX0ucmVtb3RlYCk7XG4gICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsUmVtb3RlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlbW90ZShuYW1lKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzYXZlRGlzY2FyZEhpc3RvcnkoKSB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhpc3RvcnlTaGEgPSBhd2FpdCB0aGlzLmNyZWF0ZURpc2NhcmRIaXN0b3J5QmxvYigpO1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zZXRDb25maWcoJ2F0b21HaXRodWIuaGlzdG9yeVNoYScsIGhpc3RvcnlTaGEpO1xuICB9XG59XG5cbi8vIFRoZSBtZXRob2RzIG5hbWVkIGhlcmUgd2lsbCBiZSBkZWxlZ2F0ZWQgdG8gdGhlIGN1cnJlbnQgU3RhdGUuXG4vL1xuLy8gVGhpcyBsaXN0IHNob3VsZCBtYXRjaCB0aGUgbWV0aG9kcyBkZWNvcmF0ZWQgd2l0aCBAc2hvdWxkRGVsZWdhdGUgaW4gYGxpYi9tb2RlbHMvcmVwb3NpdG9yeS1zdGF0ZXMvc3RhdGUuanNgLiBBIHRlc3Rcbi8vIGNhc2UgaW4gYHRlc3QvbW9kZWxzL3JlcG9zaXRvcnkudGVzdC5qc2AgZW5zdXJlcyB0aGF0IHRoZXNlIHNldHMgbWF0Y2guXG4vL1xuLy8gRHVwbGljYXRlZCBoZXJlIHJhdGhlciB0aGFuIGp1c3QgdXNpbmcgYGV4cGVjdGVkRGVsZWdhdGVzYCBkaXJlY3RseSBzbyB0aGF0IHRoaXMgZmlsZSBpcyBncmVwLWZyaWVuZGx5IGZvciBhbnN3ZXJpbmdcbi8vIHRoZSBxdWVzdGlvbiBvZiBcIndoYXQgYWxsIGNhbiBhIFJlcG9zaXRvcnkgZG8gZXhhY3RseVwiLlxuY29uc3QgZGVsZWdhdGVzID0gW1xuICAnaXNMb2FkaW5nR3Vlc3MnLFxuICAnaXNBYnNlbnRHdWVzcycsXG4gICdpc0Fic2VudCcsXG4gICdpc0xvYWRpbmcnLFxuICAnaXNFbXB0eScsXG4gICdpc1ByZXNlbnQnLFxuICAnaXNEZXN0cm95ZWQnLFxuXG4gICdpc1VuZGV0ZXJtaW5lZCcsXG4gICdzaG93R2l0VGFiSW5pdCcsXG4gICdzaG93R2l0VGFiSW5pdEluUHJvZ3Jlc3MnLFxuICAnc2hvd0dpdFRhYkxvYWRpbmcnLFxuICAnc2hvd1N0YXR1c0JhclRpbGVzJyxcbiAgJ2hhc0RpcmVjdG9yeScsXG5cbiAgJ2luaXQnLFxuICAnY2xvbmUnLFxuICAnZGVzdHJveScsXG4gICdyZWZyZXNoJyxcbiAgJ29ic2VydmVGaWxlc3lzdGVtQ2hhbmdlJyxcblxuICAnc3RhZ2VGaWxlcycsXG4gICd1bnN0YWdlRmlsZXMnLFxuICAnc3RhZ2VGaWxlc0Zyb21QYXJlbnRDb21taXQnLFxuICAnYXBwbHlQYXRjaFRvSW5kZXgnLFxuICAnYXBwbHlQYXRjaFRvV29ya2RpcicsXG5cbiAgJ2NvbW1pdCcsXG5cbiAgJ21lcmdlJyxcbiAgJ2Fib3J0TWVyZ2UnLFxuICAnY2hlY2tvdXRTaWRlJyxcbiAgJ21lcmdlRmlsZScsXG4gICd3cml0ZU1lcmdlQ29uZmxpY3RUb0luZGV4JyxcblxuICAnY2hlY2tvdXQnLFxuICAnY2hlY2tvdXRQYXRoc0F0UmV2aXNpb24nLFxuXG4gICdmZXRjaCcsXG4gICdwdWxsJyxcbiAgJ3B1c2gnLFxuXG4gICdzZXRDb25maWcnLFxuXG4gICdjcmVhdGVCbG9iJyxcbiAgJ2V4cGFuZEJsb2JUb0ZpbGUnLFxuXG4gICdjcmVhdGVEaXNjYXJkSGlzdG9yeUJsb2InLFxuICAndXBkYXRlRGlzY2FyZEhpc3RvcnknLFxuICAnc3RvcmVCZWZvcmVBbmRBZnRlckJsb2JzJyxcbiAgJ3Jlc3RvcmVMYXN0RGlzY2FyZEluVGVtcEZpbGVzJyxcbiAgJ3BvcERpc2NhcmRIaXN0b3J5JyxcbiAgJ2NsZWFyRGlzY2FyZEhpc3RvcnknLFxuICAnZGlzY2FyZFdvcmtEaXJDaGFuZ2VzRm9yUGF0aHMnLFxuXG4gICdnZXRTdGF0dXNCdW5kbGUnLFxuICAnZ2V0U3RhdHVzZXNGb3JDaGFuZ2VkRmlsZXMnLFxuICAnZ2V0U3RhZ2VkQ2hhbmdlc1NpbmNlUGFyZW50Q29tbWl0JyxcbiAgJ2dldEZpbGVQYXRjaEZvclBhdGgnLFxuICAncmVhZEZpbGVGcm9tSW5kZXgnLFxuXG4gICdnZXRMYXN0Q29tbWl0JyxcblxuICAnZ2V0QnJhbmNoZXMnLFxuICAnZ2V0Q3VycmVudEJyYW5jaCcsXG5cbiAgJ2lzTWVyZ2luZycsXG4gICdpc1JlYmFzaW5nJyxcblxuICAnZ2V0UmVtb3RlcycsXG5cbiAgJ2dldEFoZWFkQ291bnQnLFxuICAnZ2V0QmVoaW5kQ291bnQnLFxuXG4gICdnZXRDb25maWcnLFxuICAndW5zZXRDb25maWcnLFxuXG4gICdnZXRCbG9iQ29udGVudHMnLFxuXG4gICdoYXNEaXNjYXJkSGlzdG9yeScsXG4gICdnZXREaXNjYXJkSGlzdG9yeScsXG4gICdnZXRMYXN0SGlzdG9yeVNuYXBzaG90cycsXG5dO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IGRlbGVnYXRlcy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBkZWxlZ2F0ZSA9IGRlbGVnYXRlc1tpXTtcblxuICBSZXBvc2l0b3J5LnByb3RvdHlwZVtkZWxlZ2F0ZV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVbZGVsZWdhdGVdKC4uLmFyZ3MpO1xuICB9O1xufVxuIl19