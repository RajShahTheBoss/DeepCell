'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.GitError = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _class, _temp;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _electron = require('electron');

var _eventKit = require('event-kit');

var _dugite = require('dugite');

var _whatTheDiff = require('what-the-diff');

var _whatTheStatus = require('what-the-status');

var _gitPromptServer = require('./git-prompt-server');

var _gitPromptServer2 = _interopRequireDefault(_gitPromptServer);

var _asyncQueue = require('./async-queue');

var _asyncQueue2 = _interopRequireDefault(_asyncQueue);

var _helpers = require('./helpers');

var _gitTimingsView = require('./views/git-timings-view');

var _gitTimingsView2 = _interopRequireDefault(_gitTimingsView);

var _workerManager = require('./worker-manager');

var _workerManager2 = _interopRequireDefault(_workerManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const LINE_ENDING_REGEX = /\r?\n/;

const GPG_HELPER_PATH = _path2.default.resolve((0, _helpers.getPackageRoot)(), 'bin', 'gpg-no-tty.sh');

let headless = null;

let GitError = exports.GitError = class GitError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.stack = new Error().stack;
  }
};
let GitShellOutStrategy = (_temp = _class = class GitShellOutStrategy {

  constructor(workingDir) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this.workingDir = workingDir;
    if (options.queue) {
      this.commandQueue = options.queue;
    } else {
      const parallelism = options.parallelism || Math.max(3, _os2.default.cpus().length);
      this.commandQueue = new _asyncQueue2.default({ parallelism });
    }

    this.prompt = options.prompt || (query => Promise.reject());
    this.workerManager = options.workerManager;

    if (headless === null) {
      headless = !_electron.remote.getCurrentWindow().isVisible();
    }
  }

  /*
   * Provide an asynchronous callback to be used to request input from the user for git operations.
   *
   * `prompt` must be a callable that accepts a query object `{prompt, includeUsername}` and returns a Promise
   * that either resolves with a result object `{[username], password}` or rejects on cancellation.
   */
  setPromptCallback(prompt) {
    this.prompt = prompt;
  }

  // Execute a command and read the output using the embedded Git environment
  exec(args) {
    var _this = this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GitShellOutStrategy.defaultExecArgs;

    let stdin = _ref.stdin,
        useGitPromptServer = _ref.useGitPromptServer,
        writeOperation = _ref.writeOperation;

    /* eslint-disable no-console */
    const subscriptions = new _eventKit.CompositeDisposable();
    const diagnosticsEnabled = process.env.ATOM_GITHUB_GIT_DIAGNOSTICS || atom.config.get('github.gitDiagnostics');

    const formattedArgs = `git ${args.join(' ')} in ${this.workingDir}`;
    const timingMarker = _gitTimingsView2.default.generateMarker(`git ${args.join(' ')}`);
    timingMarker.mark('queued');

    return this.commandQueue.push(_asyncToGenerator(function* () {
      timingMarker.mark('prepare');
      let gitPromptServer;

      const env = {
        GIT_TERMINAL_PROMPT: '0',
        PATH: process.env.PATH || ''
      };

      if (useGitPromptServer) {
        gitPromptServer = new _gitPromptServer2.default();

        var _ref3 = yield gitPromptServer.start(_this.prompt);

        const socket = _ref3.socket,
              electron = _ref3.electron,
              credentialHelper = _ref3.credentialHelper,
              askPass = _ref3.askPass,
              sshWrapper = _ref3.sshWrapper;


        env.ATOM_GITHUB_ASKPASS_PATH = (0, _helpers.normalizeGitHelperPath)(askPass.script);
        env.ATOM_GITHUB_CREDENTIAL_PATH = (0, _helpers.normalizeGitHelperPath)(credentialHelper.script);
        env.ATOM_GITHUB_ELECTRON_PATH = (0, _helpers.normalizeGitHelperPath)(electron);
        env.ATOM_GITHUB_SOCK_PATH = (0, _helpers.normalizeGitHelperPath)(socket);

        env.ATOM_GITHUB_WORKDIR_PATH = _this.workingDir;
        env.ATOM_GITHUB_DUGITE_PATH = (0, _helpers.getDugitePath)();

        // "ssh" won't respect SSH_ASKPASS unless:
        // (a) it's running without a tty
        // (b) DISPLAY is set to something nonempty
        // But, on a Mac, DISPLAY is unset. Ensure that it is so our SSH_ASKPASS is respected.
        if (!process.env.DISPLAY || process.env.DISPLAY.length === 0) {
          env.DISPLAY = 'atom-github-placeholder';
        }

        env.ATOM_GITHUB_ORIGINAL_PATH = process.env.PATH || '';
        env.ATOM_GITHUB_ORIGINAL_GIT_ASKPASS = process.env.GIT_ASKPASS || '';
        env.ATOM_GITHUB_ORIGINAL_SSH_ASKPASS = process.env.SSH_ASKPASS || '';
        env.ATOM_GITHUB_ORIGINAL_GIT_SSH_COMMAND = process.env.GIT_SSH_COMMAND || '';
        env.ATOM_GITHUB_SPEC_MODE = atom.inSpecMode() ? 'true' : 'false';

        env.SSH_ASKPASS = (0, _helpers.normalizeGitHelperPath)(askPass.launcher);
        env.GIT_ASKPASS = (0, _helpers.normalizeGitHelperPath)(askPass.launcher);

        if (process.platform === 'linux') {
          env.GIT_SSH_COMMAND = sshWrapper.script;
        } else {
          env.GIT_SSH_COMMAND = process.env.GIT_SSH_COMMAND;
        }

        args.unshift('-c', `credential.helper=${(0, _helpers.normalizeGitHelperPath)(credentialHelper.launcher)}`);
      }

      if (diagnosticsEnabled) {
        env.GIT_TRACE = 'true';
        env.GIT_TRACE_CURL = 'true';
      }

      const options = { env };

      if (stdin) {
        options.stdin = stdin;
        options.stdinEncoding = 'utf8';
      }

      if (process.env.PRINT_GIT_TIMES) {
        console.time(`git:${formattedArgs}`);
      }
      return new Promise((() => {
        var _ref4 = _asyncToGenerator(function* (resolve, reject) {
          var _executeGitCommand = _this.executeGitCommand(args, options, timingMarker);

          const promise = _executeGitCommand.promise,
                cancel = _executeGitCommand.cancel;

          let expectCancel = false;
          if (gitPromptServer) {
            subscriptions.add(gitPromptServer.onDidCancel((() => {
              var _ref5 = _asyncToGenerator(function* (_ref6) {
                let handlerPid = _ref6.handlerPid;

                expectCancel = true;
                yield cancel();

                // On Windows, the SSH_ASKPASS handler is executed as a non-child process, so the bin\git-askpass-atom.sh
                // process does not terminate when the git process is killed.
                // Kill the handler process *after* the git process has been killed to ensure that git doesn't have a
                // chance to fall back to GIT_ASKPASS from the credential handler.
                require('tree-kill')(handlerPid);
              });

              return function (_x5) {
                return _ref5.apply(this, arguments);
              };
            })()));
          }

          var _ref7 = yield promise;

          const stdout = _ref7.stdout,
                stderr = _ref7.stderr,
                exitCode = _ref7.exitCode,
                timing = _ref7.timing;


          if (timing) {
            const execTime = timing.execTime,
                  spawnTime = timing.spawnTime,
                  ipcTime = timing.ipcTime;

            const now = performance.now();
            timingMarker.mark('nexttick', now - execTime - spawnTime - ipcTime);
            timingMarker.mark('execute', now - execTime - ipcTime);
            timingMarker.mark('ipc', now - ipcTime);
          }
          timingMarker.finalize();
          if (process.env.PRINT_GIT_TIMES) {
            console.timeEnd(`git:${formattedArgs}`);
          }
          if (gitPromptServer) {
            gitPromptServer.terminate();
          }
          subscriptions.dispose();

          if (diagnosticsEnabled) {
            if (headless) {
              let summary = `git:${formattedArgs}\n`;
              summary += `exit status: ${exitCode}\n`;
              summary += 'stdout:';
              if (stdout.length === 0) {
                summary += ' <empty>\n';
              } else {
                summary += `\n${stdout}\n`;
              }
              summary += 'stderr:';
              if (stderr.length === 0) {
                summary += ' <empty>\n';
              } else {
                summary += `\n${stderr}\n`;
              }

              console.log(summary);
            } else {
              const headerStyle = 'font-weight: bold; color: blue;';

              console.groupCollapsed(`git:${formattedArgs}`);
              console.log('%cexit status%c %d', headerStyle, 'font-weight: normal; color: black;', exitCode);
              console.log('%cstdout', headerStyle);
              console.log(stdout);
              console.log('%cstderr', headerStyle);
              console.log(stderr);
              console.groupEnd();
            }
          }

          if (exitCode !== 0 && !expectCancel) {
            const err = new GitError(`${formattedArgs} exited with code ${exitCode}\nstdout: ${stdout}\nstderr: ${stderr}`);
            err.code = exitCode;
            err.stdErr = stderr;
            err.stdOut = stdout;
            err.command = formattedArgs;
            reject(err);
          }
          resolve(stdout);
        });

        return function (_x3, _x4) {
          return _ref4.apply(this, arguments);
        };
      })());
    }), { parallel: !writeOperation });
    /* eslint-enable no-console */
  }

  executeGitCommand(args, options) {
    let marker = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (process.env.ATOM_GITHUB_INLINE_GIT_EXEC || !_workerManager2.default.getInstance().isReady()) {
      marker && marker.mark('nexttick');

      let childPid;
      options.processCallback = child => {
        childPid = child.pid;

        child.on('error', err => {
          /* eslint-disable no-console */
          console.error(`Error spawning: git ${args.join(' ')} in ${this.workingDir}`);
          console.error(err);
          /* eslint-enable no-console */
        });

        child.stdin.on('error', err => {
          /* eslint-disable no-console */
          console.error(`Error writing to stdin: git ${args.join(' ')} in ${this.workingDir}\n${options.stdin}`);
          console.error(err);
          /* eslint-enable no-console */
        });
      };

      const promise = _dugite.GitProcess.exec(args, this.workingDir, options);
      marker && marker.mark('execute');
      return {
        promise,
        cancel: () => childPid && require('tree-kill')(childPid)
      };
    } else {
      const workerManager = this.workerManager || _workerManager2.default.getInstance();
      return workerManager.request({
        args,
        workingDir: this.workingDir,
        options
      });
    }
  }

  /**
   * Execute a git command that may create a commit. If the command fails because the GPG binary was invoked and unable
   * to acquire a passphrase (because the pinentry program attempted to use a tty), retry with a `GitPromptServer`.
   */
  gpgExec(args) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    const gpgArgs = ['-c', `gpg.program=${GPG_HELPER_PATH}`].concat(args);
    return this.exec(gpgArgs, options).catch(err => {
      if (err.code === 128 && /gpg failed/.test(err.stdErr) && !options.useGitPromptServer) {
        // Retry with a GitPromptServer
        options.useGitPromptServer = true;
        return this.exec(gpgArgs, options);
      } else {
        throw err;
      }
    });
  }

  resolveDotGitDir() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      try {
        yield (0, _helpers.fsStat)(_this2.workingDir); // fails if folder doesn't exist
        const output = yield _this2.exec(['rev-parse', '--resolve-git-dir', _path2.default.join(_this2.workingDir, '.git')]);
        const dotGitDir = output.trim();
        if (_path2.default.isAbsolute(dotGitDir)) {
          return (0, _helpers.toNativePathSep)(dotGitDir);
        } else {
          return (0, _helpers.toNativePathSep)(_path2.default.resolve(_path2.default.join(_this2.workingDir, dotGitDir)));
        }
      } catch (e) {
        return null;
      }
    })();
  }

  init() {
    return this.exec(['init', this.workingDir]);
  }

  /**
   * Staging/Unstaging files and patches and committing
   */
  stageFiles(paths) {
    if (paths.length === 0) {
      return Promise.resolve(null);
    }
    const args = ['add'].concat(paths.map(_helpers.toGitPathSep));
    return this.exec(args, { writeOperation: true });
  }

  unstageFiles(paths) {
    let commit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'HEAD';

    if (paths.length === 0) {
      return Promise.resolve(null);
    }
    const args = ['reset', commit, '--'].concat(paths.map(_helpers.toGitPathSep));
    return this.exec(args, { writeOperation: true });
  }

  applyPatch(patch) {
    var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    let index = _ref8.index;

    const args = ['apply', '-'];
    if (index) {
      args.splice(1, 0, '--cached');
    }
    return this.exec(args, { stdin: patch, writeOperation: true });
  }

  commit(message) {
    var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    let allowEmpty = _ref9.allowEmpty,
        amend = _ref9.amend;

    const args = ['commit', '-m', message];
    if (amend) {
      args.push('--amend');
    }
    if (allowEmpty) {
      args.push('--allow-empty');
    }
    return this.gpgExec(args, { writeOperation: true });
  }

  /**
   * File Status and Diffs
   */
  getStatusBundle() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const args = ['status', '--porcelain=v2', '--branch', '--untracked-files=all', '--ignore-submodules=dirty', '-z'];
      const output = yield _this3.exec(args);
      const results = (0, _whatTheStatus.parse)(output);

      for (const entryType in results) {
        if (Array.isArray(results[entryType])) {
          _this3.updateNativePathSepForEntries(results[entryType]);
        }
      }

      return results;
    })();
  }

  updateNativePathSepForEntries(entries) {
    entries.forEach(entry => {
      // Normally we would avoid mutating responses from other package's APIs, but we control
      // the `what-the-status` module and know there are no side effects.
      // This is a hot code path and by mutating we avoid creating new objects that will just be GC'ed
      if (entry.filePath) {
        entry.filePath = (0, _helpers.toNativePathSep)(entry.filePath);
      }
      if (entry.origFilePath) {
        entry.origFilePath = (0, _helpers.toNativePathSep)(entry.origFilePath);
      }
    });
  }

  diffFileStatus() {
    var _this4 = this;

    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return _asyncToGenerator(function* () {
      const args = ['diff', '--name-status', '--no-renames'];
      if (options.staged) {
        args.push('--staged');
      }
      if (options.target) {
        args.push(options.target);
      }
      const output = yield _this4.exec(args);

      const statusMap = {
        A: 'added',
        M: 'modified',
        D: 'deleted',
        U: 'unmerged'
      };

      const fileStatuses = {};
      output && output.trim().split(LINE_ENDING_REGEX).forEach(function (line) {
        var _line$split = line.split('\t'),
            _line$split2 = _slicedToArray(_line$split, 2);

        const status = _line$split2[0],
              rawFilePath = _line$split2[1];

        const filePath = (0, _helpers.toNativePathSep)(rawFilePath);
        fileStatuses[filePath] = statusMap[status];
      });
      if (!options.staged) {
        const untracked = yield _this4.getUntrackedFiles();
        untracked.forEach(function (filePath) {
          fileStatuses[filePath] = 'added';
        });
      }
      return fileStatuses;
    })();
  }

  getUntrackedFiles() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      const output = yield _this5.exec(['ls-files', '--others', '--exclude-standard']);
      if (output.trim() === '') {
        return [];
      }
      return output.trim().split(LINE_ENDING_REGEX).map(_helpers.toNativePathSep);
    })();
  }

  getDiffForFilePath(filePath) {
    var _this6 = this;

    var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    let staged = _ref10.staged,
        baseCommit = _ref10.baseCommit;
    return _asyncToGenerator(function* () {
      let args = ['diff', '--no-prefix', '--no-renames', '--diff-filter=u'];
      if (staged) {
        args.push('--staged');
      }
      if (baseCommit) {
        args.push(baseCommit);
      }
      args = args.concat(['--', (0, _helpers.toGitPathSep)(filePath)]);
      const output = yield _this6.exec(args);

      let rawDiffs = [];
      if (output) {
        rawDiffs = (0, _whatTheDiff.parse)(output).filter(function (rawDiff) {
          return rawDiff.status !== 'unmerged';
        });

        for (let i = 0; i < rawDiffs.length; i++) {
          const rawDiff = rawDiffs[i];
          if (rawDiff.oldPath) {
            rawDiff.oldPath = (0, _helpers.toNativePathSep)(rawDiff.oldPath);
          }
          if (rawDiff.newPath) {
            rawDiff.newPath = (0, _helpers.toNativePathSep)(rawDiff.newPath);
          }
        }
      }

      if (!staged && (yield _this6.getUntrackedFiles()).includes(filePath)) {
        // add untracked file
        const absPath = _path2.default.join(_this6.workingDir, filePath);
        const executable = yield (0, _helpers.isFileExecutable)(absPath);
        const contents = yield (0, _helpers.readFile)(absPath);
        const binary = (0, _helpers.isBinary)(contents);
        rawDiffs.push(buildAddedFilePatch(filePath, binary ? null : contents, executable));
      }
      if (rawDiffs.length > 1) {
        throw new Error(`Expected 0 or 1 diffs for ${filePath} but got ${rawDiffs.length}`);
      }
      return rawDiffs[0];
    })();
  }

  /**
   * Miscellaneous getters
   */
  getCommit(ref) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      const output = yield _this7.exec(['log', '--pretty=%H%x00%B%x00', '--no-abbrev-commit', '-1', ref]);

      var _output$split = output.split('\0'),
          _output$split2 = _slicedToArray(_output$split, 2);

      const sha = _output$split2[0],
            message = _output$split2[1];

      return { sha, message: message.trim(), unbornRef: false };
    })();
  }

  getHeadCommit() {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      try {
        const commit = yield _this8.getCommit('HEAD');
        commit.unbornRef = false;
        return commit;
      } catch (e) {
        if (/unknown revision/.test(e.stdErr)) {
          return { sha: '', message: '', unbornRef: true };
        } else {
          throw e;
        }
      }
    })();
  }

  readFileFromIndex(filePath) {
    return this.exec(['show', `:${(0, _helpers.toGitPathSep)(filePath)}`]);
  }

  /**
   * Merge
   */
  merge(branchName) {
    return this.gpgExec(['merge', branchName], { writeOperation: true });
  }

  isMerging(dotGitDir) {
    return _asyncToGenerator(function* () {
      try {
        yield (0, _helpers.readFile)(_path2.default.join(dotGitDir, 'MERGE_HEAD'));
        return true;
      } catch (e) {
        return false;
      }
    })();
  }

  abortMerge() {
    return this.exec(['merge', '--abort'], { writeOperation: true });
  }

  checkoutSide(side, paths) {
    if (paths.length === 0) {
      return Promise.resolve();
    }

    return this.exec(['checkout', `--${side}`, ...paths.map(_helpers.toGitPathSep)]);
  }

  /**
   * Rebase
   */
  isRebasing(dotGitDir) {
    return _asyncToGenerator(function* () {
      const results = yield Promise.all([(0, _helpers.fileExists)(_path2.default.join(dotGitDir, 'rebase-merge')), (0, _helpers.fileExists)(_path2.default.join(dotGitDir, 'rebase-apply'))]);
      return results.some(function (r) {
        return r;
      });
    })();
  }

  /**
   * Remote interactions
   */
  clone(remoteUrl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    const args = ['clone'];
    if (options.noLocal) {
      args.push('--no-local');
    }
    if (options.bare) {
      args.push('--bare');
    }
    if (options.recursive) {
      args.push('--recursive');
    }
    args.push(remoteUrl, this.workingDir);

    return this.exec(args, { writeOperation: true });
  }

  fetch(remoteName, branchName) {
    return this.exec(['fetch', remoteName, branchName], { useGitPromptServer: true, writeOperation: true });
  }

  pull(remoteName, branchName) {
    return this.gpgExec(['pull', remoteName, branchName], { useGitPromptServer: true, writeOperation: true });
  }

  push(remoteName, branchName) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    const args = ['push', remoteName || 'origin', branchName];
    if (options.setUpstream) {
      args.push('--set-upstream');
    }
    if (options.force) {
      args.push('--force');
    }
    return this.exec(args, { useGitPromptServer: true, writeOperation: true });
  }

  /**
   * Branches
   */
  checkout(branchName) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    const args = ['checkout'];
    if (options.createNew) {
      args.push('-b');
    }
    return this.exec(args.concat(branchName), { writeOperation: true });
  }

  checkoutFiles(paths, revision) {
    if (paths.length === 0) {
      return null;
    }
    const args = ['checkout'];
    if (revision) {
      args.push(revision);
    }
    return this.exec(args.concat('--', paths.map(_helpers.toGitPathSep)), { writeOperation: true });
  }

  getBranches() {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      const output = yield _this9.exec(['for-each-ref', '--format=%(refname:short)', 'refs/heads/**']);
      return output.trim().split(LINE_ENDING_REGEX);
    })();
  }

  describeHead() {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      return (yield _this10.exec(['describe', '--contains', '--all', '--always', 'HEAD'])).trim();
    })();
  }

  getConfig(option) {
    var _this11 = this;

    var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    let local = _ref11.local;
    return _asyncToGenerator(function* () {
      let output;
      try {
        let args = ['config'];
        if (local) {
          args.push('--local');
        }
        args = args.concat(option);
        output = yield _this11.exec(args);
      } catch (err) {
        if (err.code === 1) {
          // No matching config found
          return null;
        } else {
          throw err;
        }
      }

      return output.trim();
    })();
  }

  setConfig(option, value) {
    var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    let replaceAll = _ref12.replaceAll;

    let args = ['config'];
    if (replaceAll) {
      args.push('--replace-all');
    }
    args = args.concat(option, value);
    return this.exec(args, { writeOperation: true });
  }

  unsetConfig(option) {
    return this.exec(['config', '--unset', option], { writeOperation: true });
  }

  getRemotes() {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      let output = yield _this12.getConfig(['--get-regexp', '^remote\\..*\\.url$'], { local: true });
      if (output) {
        output = output.trim();
        if (!output.length) {
          return [];
        }
        return output.split('\n').map(function (line) {
          const match = line.match(/^remote\.(.*)\.url (.*)$/);
          return {
            name: match[1],
            url: match[2]
          };
        });
      } else {
        return [];
      }
    })();
  }

  createBlob() {
    var _this13 = this;

    var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    let filePath = _ref13.filePath,
        stdin = _ref13.stdin;
    return _asyncToGenerator(function* () {
      let output;
      if (filePath) {
        try {
          output = (yield _this13.exec(['hash-object', '-w', filePath], { writeOperation: true })).trim();
        } catch (e) {
          if (e.stdErr && e.stdErr.match(/fatal: Cannot open .*: No such file or directory/)) {
            output = null;
          } else {
            throw e;
          }
        }
      } else if (stdin) {
        output = (yield _this13.exec(['hash-object', '-w', '--stdin'], { stdin, writeOperation: true })).trim();
      } else {
        throw new Error('Must supply file path or stdin');
      }
      return output;
    })();
  }

  expandBlobToFile(absFilePath, sha) {
    var _this14 = this;

    return _asyncToGenerator(function* () {
      const output = yield _this14.exec(['cat-file', '-p', sha]);
      yield (0, _helpers.writeFile)(absFilePath, output);
      return absFilePath;
    })();
  }

  getBlobContents(sha) {
    var _this15 = this;

    return _asyncToGenerator(function* () {
      return yield _this15.exec(['cat-file', '-p', sha]);
    })();
  }

  mergeFile(oursPath, commonBasePath, theirsPath, resultPath) {
    var _this16 = this;

    return _asyncToGenerator(function* () {
      const args = ['merge-file', '-p', oursPath, commonBasePath, theirsPath, '-L', 'current', '-L', 'after discard', '-L', 'before discard'];
      let output;
      let conflict = false;
      try {
        output = yield _this16.exec(args);
      } catch (e) {
        if (e instanceof GitError && e.code === 1) {
          output = e.stdOut;
          conflict = true;
        } else {
          throw e;
        }
      }

      // Interpret a relative resultPath as relative to the repository working directory for consistency with the
      // other arguments.
      const resolvedResultPath = _path2.default.resolve(_this16.workingDir, resultPath);
      yield (0, _helpers.writeFile)(resolvedResultPath, output);

      return { filePath: oursPath, resultPath, conflict };
    })();
  }

  writeMergeConflictToIndex(filePath, commonBaseSha, oursSha, theirsSha) {
    var _this17 = this;

    return _asyncToGenerator(function* () {
      const gitFilePath = (0, _helpers.toGitPathSep)(filePath);
      const fileMode = yield _this17.getFileMode(filePath);
      let indexInfo = `0 0000000000000000000000000000000000000000\t${gitFilePath}\n`;
      if (commonBaseSha) {
        indexInfo += `${fileMode} ${commonBaseSha} 1\t${gitFilePath}\n`;
      }
      if (oursSha) {
        indexInfo += `${fileMode} ${oursSha} 2\t${gitFilePath}\n`;
      }
      if (theirsSha) {
        indexInfo += `${fileMode} ${theirsSha} 3\t${gitFilePath}\n`;
      }
      return _this17.exec(['update-index', '--index-info'], { stdin: indexInfo, writeOperation: true });
    })();
  }

  getFileMode(filePath) {
    var _this18 = this;

    return _asyncToGenerator(function* () {
      const output = yield _this18.exec(['ls-files', '--stage', '--', (0, _helpers.toGitPathSep)(filePath)]);
      if (output) {
        return output.slice(0, 6);
      } else {
        const executable = yield (0, _helpers.isFileExecutable)(_path2.default.join(_this18.workingDir, filePath));
        return executable ? '100755' : '100644';
      }
    })();
  }

  destroy() {
    this.commandQueue.dispose();
  }
}, _class.defaultExecArgs = { stdin: null, useGitPromptServer: false, writeOperation: false }, _temp);
exports.default = GitShellOutStrategy;


function buildAddedFilePatch(filePath, contents, executable) {
  const hunks = [];
  if (contents) {
    const noNewLine = contents[contents.length - 1] !== '\n';
    const lines = contents.trim().split(LINE_ENDING_REGEX).map(line => `+${line}`);
    if (noNewLine) {
      lines.push('\\ No newline at end of file');
    }
    hunks.push({
      lines,
      oldStartLine: 0,
      oldLineCount: 0,
      newStartLine: 1,
      heading: '',
      newLineCount: noNewLine ? lines.length - 1 : lines.length
    });
  }
  return {
    oldPath: null,
    newPath: (0, _helpers.toNativePathSep)(filePath),
    oldMode: null,
    newMode: executable ? '100755' : '100644',
    status: 'added',
    hunks
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImdpdC1zaGVsbC1vdXQtc3RyYXRlZ3kuanMiXSwibmFtZXMiOlsiTElORV9FTkRJTkdfUkVHRVgiLCJHUEdfSEVMUEVSX1BBVEgiLCJyZXNvbHZlIiwiaGVhZGxlc3MiLCJHaXRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhY2siLCJHaXRTaGVsbE91dFN0cmF0ZWd5Iiwid29ya2luZ0RpciIsIm9wdGlvbnMiLCJxdWV1ZSIsImNvbW1hbmRRdWV1ZSIsInBhcmFsbGVsaXNtIiwiTWF0aCIsIm1heCIsImNwdXMiLCJsZW5ndGgiLCJwcm9tcHQiLCJxdWVyeSIsIlByb21pc2UiLCJyZWplY3QiLCJ3b3JrZXJNYW5hZ2VyIiwiZ2V0Q3VycmVudFdpbmRvdyIsImlzVmlzaWJsZSIsInNldFByb21wdENhbGxiYWNrIiwiZXhlYyIsImFyZ3MiLCJkZWZhdWx0RXhlY0FyZ3MiLCJzdGRpbiIsInVzZUdpdFByb21wdFNlcnZlciIsIndyaXRlT3BlcmF0aW9uIiwic3Vic2NyaXB0aW9ucyIsImRpYWdub3N0aWNzRW5hYmxlZCIsInByb2Nlc3MiLCJlbnYiLCJBVE9NX0dJVEhVQl9HSVRfRElBR05PU1RJQ1MiLCJhdG9tIiwiY29uZmlnIiwiZ2V0IiwiZm9ybWF0dGVkQXJncyIsImpvaW4iLCJ0aW1pbmdNYXJrZXIiLCJnZW5lcmF0ZU1hcmtlciIsIm1hcmsiLCJwdXNoIiwiZ2l0UHJvbXB0U2VydmVyIiwiR0lUX1RFUk1JTkFMX1BST01QVCIsIlBBVEgiLCJzdGFydCIsInNvY2tldCIsImVsZWN0cm9uIiwiY3JlZGVudGlhbEhlbHBlciIsImFza1Bhc3MiLCJzc2hXcmFwcGVyIiwiQVRPTV9HSVRIVUJfQVNLUEFTU19QQVRIIiwic2NyaXB0IiwiQVRPTV9HSVRIVUJfQ1JFREVOVElBTF9QQVRIIiwiQVRPTV9HSVRIVUJfRUxFQ1RST05fUEFUSCIsIkFUT01fR0lUSFVCX1NPQ0tfUEFUSCIsIkFUT01fR0lUSFVCX1dPUktESVJfUEFUSCIsIkFUT01fR0lUSFVCX0RVR0lURV9QQVRIIiwiRElTUExBWSIsIkFUT01fR0lUSFVCX09SSUdJTkFMX1BBVEgiLCJBVE9NX0dJVEhVQl9PUklHSU5BTF9HSVRfQVNLUEFTUyIsIkdJVF9BU0tQQVNTIiwiQVRPTV9HSVRIVUJfT1JJR0lOQUxfU1NIX0FTS1BBU1MiLCJTU0hfQVNLUEFTUyIsIkFUT01fR0lUSFVCX09SSUdJTkFMX0dJVF9TU0hfQ09NTUFORCIsIkdJVF9TU0hfQ09NTUFORCIsIkFUT01fR0lUSFVCX1NQRUNfTU9ERSIsImluU3BlY01vZGUiLCJsYXVuY2hlciIsInBsYXRmb3JtIiwidW5zaGlmdCIsIkdJVF9UUkFDRSIsIkdJVF9UUkFDRV9DVVJMIiwic3RkaW5FbmNvZGluZyIsIlBSSU5UX0dJVF9USU1FUyIsImNvbnNvbGUiLCJ0aW1lIiwiZXhlY3V0ZUdpdENvbW1hbmQiLCJwcm9taXNlIiwiY2FuY2VsIiwiZXhwZWN0Q2FuY2VsIiwiYWRkIiwib25EaWRDYW5jZWwiLCJoYW5kbGVyUGlkIiwicmVxdWlyZSIsInN0ZG91dCIsInN0ZGVyciIsImV4aXRDb2RlIiwidGltaW5nIiwiZXhlY1RpbWUiLCJzcGF3blRpbWUiLCJpcGNUaW1lIiwibm93IiwicGVyZm9ybWFuY2UiLCJmaW5hbGl6ZSIsInRpbWVFbmQiLCJ0ZXJtaW5hdGUiLCJkaXNwb3NlIiwic3VtbWFyeSIsImxvZyIsImhlYWRlclN0eWxlIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsImVyciIsImNvZGUiLCJzdGRFcnIiLCJzdGRPdXQiLCJjb21tYW5kIiwicGFyYWxsZWwiLCJtYXJrZXIiLCJBVE9NX0dJVEhVQl9JTkxJTkVfR0lUX0VYRUMiLCJnZXRJbnN0YW5jZSIsImlzUmVhZHkiLCJjaGlsZFBpZCIsInByb2Nlc3NDYWxsYmFjayIsImNoaWxkIiwicGlkIiwib24iLCJlcnJvciIsInJlcXVlc3QiLCJncGdFeGVjIiwiZ3BnQXJncyIsImNvbmNhdCIsImNhdGNoIiwidGVzdCIsInJlc29sdmVEb3RHaXREaXIiLCJvdXRwdXQiLCJkb3RHaXREaXIiLCJ0cmltIiwiaXNBYnNvbHV0ZSIsImUiLCJpbml0Iiwic3RhZ2VGaWxlcyIsInBhdGhzIiwibWFwIiwidW5zdGFnZUZpbGVzIiwiY29tbWl0IiwiYXBwbHlQYXRjaCIsInBhdGNoIiwiaW5kZXgiLCJzcGxpY2UiLCJhbGxvd0VtcHR5IiwiYW1lbmQiLCJnZXRTdGF0dXNCdW5kbGUiLCJyZXN1bHRzIiwiZW50cnlUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwidXBkYXRlTmF0aXZlUGF0aFNlcEZvckVudHJpZXMiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiZmlsZVBhdGgiLCJvcmlnRmlsZVBhdGgiLCJkaWZmRmlsZVN0YXR1cyIsInN0YWdlZCIsInRhcmdldCIsInN0YXR1c01hcCIsIkEiLCJNIiwiRCIsIlUiLCJmaWxlU3RhdHVzZXMiLCJzcGxpdCIsImxpbmUiLCJzdGF0dXMiLCJyYXdGaWxlUGF0aCIsInVudHJhY2tlZCIsImdldFVudHJhY2tlZEZpbGVzIiwiZ2V0RGlmZkZvckZpbGVQYXRoIiwiYmFzZUNvbW1pdCIsInJhd0RpZmZzIiwiZmlsdGVyIiwicmF3RGlmZiIsImkiLCJvbGRQYXRoIiwibmV3UGF0aCIsImluY2x1ZGVzIiwiYWJzUGF0aCIsImV4ZWN1dGFibGUiLCJjb250ZW50cyIsImJpbmFyeSIsImJ1aWxkQWRkZWRGaWxlUGF0Y2giLCJnZXRDb21taXQiLCJyZWYiLCJzaGEiLCJ1bmJvcm5SZWYiLCJnZXRIZWFkQ29tbWl0IiwicmVhZEZpbGVGcm9tSW5kZXgiLCJtZXJnZSIsImJyYW5jaE5hbWUiLCJpc01lcmdpbmciLCJhYm9ydE1lcmdlIiwiY2hlY2tvdXRTaWRlIiwic2lkZSIsImlzUmViYXNpbmciLCJhbGwiLCJzb21lIiwiciIsImNsb25lIiwicmVtb3RlVXJsIiwibm9Mb2NhbCIsImJhcmUiLCJyZWN1cnNpdmUiLCJmZXRjaCIsInJlbW90ZU5hbWUiLCJwdWxsIiwic2V0VXBzdHJlYW0iLCJmb3JjZSIsImNoZWNrb3V0IiwiY3JlYXRlTmV3IiwiY2hlY2tvdXRGaWxlcyIsInJldmlzaW9uIiwiZ2V0QnJhbmNoZXMiLCJkZXNjcmliZUhlYWQiLCJnZXRDb25maWciLCJvcHRpb24iLCJsb2NhbCIsInNldENvbmZpZyIsInZhbHVlIiwicmVwbGFjZUFsbCIsInVuc2V0Q29uZmlnIiwiZ2V0UmVtb3RlcyIsIm1hdGNoIiwibmFtZSIsInVybCIsImNyZWF0ZUJsb2IiLCJleHBhbmRCbG9iVG9GaWxlIiwiYWJzRmlsZVBhdGgiLCJnZXRCbG9iQ29udGVudHMiLCJtZXJnZUZpbGUiLCJvdXJzUGF0aCIsImNvbW1vbkJhc2VQYXRoIiwidGhlaXJzUGF0aCIsInJlc3VsdFBhdGgiLCJjb25mbGljdCIsInJlc29sdmVkUmVzdWx0UGF0aCIsIndyaXRlTWVyZ2VDb25mbGljdFRvSW5kZXgiLCJjb21tb25CYXNlU2hhIiwib3Vyc1NoYSIsInRoZWlyc1NoYSIsImdpdEZpbGVQYXRoIiwiZmlsZU1vZGUiLCJnZXRGaWxlTW9kZSIsImluZGV4SW5mbyIsInNsaWNlIiwiZGVzdHJveSIsImh1bmtzIiwibm9OZXdMaW5lIiwibGluZXMiLCJvbGRTdGFydExpbmUiLCJvbGRMaW5lQ291bnQiLCJuZXdTdGFydExpbmUiLCJoZWFkaW5nIiwibmV3TGluZUNvdW50Iiwib2xkTW9kZSIsIm5ld01vZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFLQTs7OztBQUNBOzs7Ozs7OztBQUVBLE1BQU1BLG9CQUFvQixPQUExQjs7QUFFQSxNQUFNQyxrQkFBa0IsZUFBS0MsT0FBTCxDQUFhLDhCQUFiLEVBQStCLEtBQS9CLEVBQXNDLGVBQXRDLENBQXhCOztBQUVBLElBQUlDLFdBQVcsSUFBZjs7SUFFYUMsUSxXQUFBQSxRLEdBQU4sTUFBTUEsUUFBTixTQUF1QkMsS0FBdkIsQ0FBNkI7QUFDbENDLGNBQVlDLE9BQVosRUFBcUI7QUFD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QUFDQyxPQUFPLElBQVIsRUFBY0Msb0JBQW9CLEtBQWxDLEVBQXlDQyxnQkFBZ0IsS0FBekQsRTtrQkFETnZCLG1COzs7QUEwbkJyQixTQUFTa0wsbUJBQVQsQ0FBNkI5QixRQUE3QixFQUF1QzRCLFFBQXZDLEVBQWlERCxVQUFqRCxFQUE2RDtBQUMzRCxRQUFNb0UsUUFBUSxFQUFkO0FBQ0EsTUFBSW5FLFFBQUosRUFBYztBQUNaLFVBQU1vRSxZQUFZcEUsU0FBU0EsU0FBU3ZLLE1BQVQsR0FBa0IsQ0FBM0IsTUFBa0MsSUFBcEQ7QUFDQSxVQUFNNE8sUUFBUXJFLFNBQVNwRCxJQUFULEdBQWdCbUMsS0FBaEIsQ0FBc0J4SyxpQkFBdEIsRUFBeUMySSxHQUF6QyxDQUE2QzhCLFFBQVMsSUFBR0EsSUFBSyxFQUE5RCxDQUFkO0FBQ0EsUUFBSW9GLFNBQUosRUFBZTtBQUFFQyxZQUFNaE4sSUFBTixDQUFXLDhCQUFYO0FBQTZDO0FBQzlEOE0sVUFBTTlNLElBQU4sQ0FBVztBQUNUZ04sV0FEUztBQUVUQyxvQkFBYyxDQUZMO0FBR1RDLG9CQUFjLENBSEw7QUFJVEMsb0JBQWMsQ0FKTDtBQUtUQyxlQUFTLEVBTEE7QUFNVEMsb0JBQWNOLFlBQVlDLE1BQU01TyxNQUFOLEdBQWUsQ0FBM0IsR0FBK0I0TyxNQUFNNU87QUFOMUMsS0FBWDtBQVFEO0FBQ0QsU0FBTztBQUNMa0ssYUFBUyxJQURKO0FBRUxDLGFBQVMsOEJBQWdCeEIsUUFBaEIsQ0FGSjtBQUdMdUcsYUFBUyxJQUhKO0FBSUxDLGFBQVM3RSxhQUFhLFFBQWIsR0FBd0IsUUFKNUI7QUFLTGQsWUFBUSxPQUxIO0FBTUxrRjtBQU5LLEdBQVA7QUFRRCIsImZpbGUiOiJnaXQtc2hlbGwtb3V0LXN0cmF0ZWd5LmpzIiwic291cmNlUm9vdCI6IkM6L3Byb2plY3RzL2F0b20vb3V0L2FwcC9ub2RlX21vZHVsZXMvZ2l0aHViIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHtyZW1vdGV9IGZyb20gJ2VsZWN0cm9uJztcblxuaW1wb3J0IHtDb21wb3NpdGVEaXNwb3NhYmxlfSBmcm9tICdldmVudC1raXQnO1xuaW1wb3J0IHtHaXRQcm9jZXNzfSBmcm9tICdkdWdpdGUnO1xuaW1wb3J0IHtwYXJzZSBhcyBwYXJzZURpZmZ9IGZyb20gJ3doYXQtdGhlLWRpZmYnO1xuaW1wb3J0IHtwYXJzZSBhcyBwYXJzZVN0YXR1c30gZnJvbSAnd2hhdC10aGUtc3RhdHVzJztcblxuaW1wb3J0IEdpdFByb21wdFNlcnZlciBmcm9tICcuL2dpdC1wcm9tcHQtc2VydmVyJztcbmltcG9ydCBBc3luY1F1ZXVlIGZyb20gJy4vYXN5bmMtcXVldWUnO1xuaW1wb3J0IHtcbiAgZ2V0UGFja2FnZVJvb3QsIGdldER1Z2l0ZVBhdGgsXG4gIHJlYWRGaWxlLCBmaWxlRXhpc3RzLCBmc1N0YXQsIHdyaXRlRmlsZSwgaXNGaWxlRXhlY3V0YWJsZSwgaXNCaW5hcnksXG4gIG5vcm1hbGl6ZUdpdEhlbHBlclBhdGgsIHRvTmF0aXZlUGF0aFNlcCwgdG9HaXRQYXRoU2VwLFxufSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IEdpdFRpbWluZ3NWaWV3IGZyb20gJy4vdmlld3MvZ2l0LXRpbWluZ3Mtdmlldyc7XG5pbXBvcnQgV29ya2VyTWFuYWdlciBmcm9tICcuL3dvcmtlci1tYW5hZ2VyJztcblxuY29uc3QgTElORV9FTkRJTkdfUkVHRVggPSAvXFxyP1xcbi87XG5cbmNvbnN0IEdQR19IRUxQRVJfUEFUSCA9IHBhdGgucmVzb2x2ZShnZXRQYWNrYWdlUm9vdCgpLCAnYmluJywgJ2dwZy1uby10dHkuc2gnKTtcblxubGV0IGhlYWRsZXNzID0gbnVsbDtcblxuZXhwb3J0IGNsYXNzIEdpdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2l0U2hlbGxPdXRTdHJhdGVneSB7XG4gIHN0YXRpYyBkZWZhdWx0RXhlY0FyZ3MgPSB7c3RkaW46IG51bGwsIHVzZUdpdFByb21wdFNlcnZlcjogZmFsc2UsIHdyaXRlT3BlcmF0aW9uOiBmYWxzZX1cblxuICBjb25zdHJ1Y3Rvcih3b3JraW5nRGlyLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLndvcmtpbmdEaXIgPSB3b3JraW5nRGlyO1xuICAgIGlmIChvcHRpb25zLnF1ZXVlKSB7XG4gICAgICB0aGlzLmNvbW1hbmRRdWV1ZSA9IG9wdGlvbnMucXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmFsbGVsaXNtID0gb3B0aW9ucy5wYXJhbGxlbGlzbSB8fCBNYXRoLm1heCgzLCBvcy5jcHVzKCkubGVuZ3RoKTtcbiAgICAgIHRoaXMuY29tbWFuZFF1ZXVlID0gbmV3IEFzeW5jUXVldWUoe3BhcmFsbGVsaXNtfSk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9tcHQgPSBvcHRpb25zLnByb21wdCB8fCAocXVlcnkgPT4gUHJvbWlzZS5yZWplY3QoKSk7XG4gICAgdGhpcy53b3JrZXJNYW5hZ2VyID0gb3B0aW9ucy53b3JrZXJNYW5hZ2VyO1xuXG4gICAgaWYgKGhlYWRsZXNzID09PSBudWxsKSB7XG4gICAgICBoZWFkbGVzcyA9ICFyZW1vdGUuZ2V0Q3VycmVudFdpbmRvdygpLmlzVmlzaWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIFByb3ZpZGUgYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrIHRvIGJlIHVzZWQgdG8gcmVxdWVzdCBpbnB1dCBmcm9tIHRoZSB1c2VyIGZvciBnaXQgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogYHByb21wdGAgbXVzdCBiZSBhIGNhbGxhYmxlIHRoYXQgYWNjZXB0cyBhIHF1ZXJ5IG9iamVjdCBge3Byb21wdCwgaW5jbHVkZVVzZXJuYW1lfWAgYW5kIHJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgZWl0aGVyIHJlc29sdmVzIHdpdGggYSByZXN1bHQgb2JqZWN0IGB7W3VzZXJuYW1lXSwgcGFzc3dvcmR9YCBvciByZWplY3RzIG9uIGNhbmNlbGxhdGlvbi5cbiAgICovXG4gIHNldFByb21wdENhbGxiYWNrKHByb21wdCkge1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICB9XG5cbiAgLy8gRXhlY3V0ZSBhIGNvbW1hbmQgYW5kIHJlYWQgdGhlIG91dHB1dCB1c2luZyB0aGUgZW1iZWRkZWQgR2l0IGVudmlyb25tZW50XG4gIGV4ZWMoYXJncywge3N0ZGluLCB1c2VHaXRQcm9tcHRTZXJ2ZXIsIHdyaXRlT3BlcmF0aW9ufSA9IEdpdFNoZWxsT3V0U3RyYXRlZ3kuZGVmYXVsdEV4ZWNBcmdzKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgIGNvbnN0IGRpYWdub3N0aWNzRW5hYmxlZCA9IHByb2Nlc3MuZW52LkFUT01fR0lUSFVCX0dJVF9ESUFHTk9TVElDUyB8fCBhdG9tLmNvbmZpZy5nZXQoJ2dpdGh1Yi5naXREaWFnbm9zdGljcycpO1xuXG4gICAgY29uc3QgZm9ybWF0dGVkQXJncyA9IGBnaXQgJHthcmdzLmpvaW4oJyAnKX0gaW4gJHt0aGlzLndvcmtpbmdEaXJ9YDtcbiAgICBjb25zdCB0aW1pbmdNYXJrZXIgPSBHaXRUaW1pbmdzVmlldy5nZW5lcmF0ZU1hcmtlcihgZ2l0ICR7YXJncy5qb2luKCcgJyl9YCk7XG4gICAgdGltaW5nTWFya2VyLm1hcmsoJ3F1ZXVlZCcpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgdGltaW5nTWFya2VyLm1hcmsoJ3ByZXBhcmUnKTtcbiAgICAgIGxldCBnaXRQcm9tcHRTZXJ2ZXI7XG5cbiAgICAgIGNvbnN0IGVudiA9IHtcbiAgICAgICAgR0lUX1RFUk1JTkFMX1BST01QVDogJzAnLFxuICAgICAgICBQQVRIOiBwcm9jZXNzLmVudi5QQVRIIHx8ICcnLFxuICAgICAgfTtcblxuICAgICAgaWYgKHVzZUdpdFByb21wdFNlcnZlcikge1xuICAgICAgICBnaXRQcm9tcHRTZXJ2ZXIgPSBuZXcgR2l0UHJvbXB0U2VydmVyKCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzb2NrZXQsIGVsZWN0cm9uLCBjcmVkZW50aWFsSGVscGVyLCBhc2tQYXNzLCBzc2hXcmFwcGVyLFxuICAgICAgICB9ID0gYXdhaXQgZ2l0UHJvbXB0U2VydmVyLnN0YXJ0KHRoaXMucHJvbXB0KTtcblxuICAgICAgICBlbnYuQVRPTV9HSVRIVUJfQVNLUEFTU19QQVRIID0gbm9ybWFsaXplR2l0SGVscGVyUGF0aChhc2tQYXNzLnNjcmlwdCk7XG4gICAgICAgIGVudi5BVE9NX0dJVEhVQl9DUkVERU5USUFMX1BBVEggPSBub3JtYWxpemVHaXRIZWxwZXJQYXRoKGNyZWRlbnRpYWxIZWxwZXIuc2NyaXB0KTtcbiAgICAgICAgZW52LkFUT01fR0lUSFVCX0VMRUNUUk9OX1BBVEggPSBub3JtYWxpemVHaXRIZWxwZXJQYXRoKGVsZWN0cm9uKTtcbiAgICAgICAgZW52LkFUT01fR0lUSFVCX1NPQ0tfUEFUSCA9IG5vcm1hbGl6ZUdpdEhlbHBlclBhdGgoc29ja2V0KTtcblxuICAgICAgICBlbnYuQVRPTV9HSVRIVUJfV09SS0RJUl9QQVRIID0gdGhpcy53b3JraW5nRGlyO1xuICAgICAgICBlbnYuQVRPTV9HSVRIVUJfRFVHSVRFX1BBVEggPSBnZXREdWdpdGVQYXRoKCk7XG5cbiAgICAgICAgLy8gXCJzc2hcIiB3b24ndCByZXNwZWN0IFNTSF9BU0tQQVNTIHVubGVzczpcbiAgICAgICAgLy8gKGEpIGl0J3MgcnVubmluZyB3aXRob3V0IGEgdHR5XG4gICAgICAgIC8vIChiKSBESVNQTEFZIGlzIHNldCB0byBzb21ldGhpbmcgbm9uZW1wdHlcbiAgICAgICAgLy8gQnV0LCBvbiBhIE1hYywgRElTUExBWSBpcyB1bnNldC4gRW5zdXJlIHRoYXQgaXQgaXMgc28gb3VyIFNTSF9BU0tQQVNTIGlzIHJlc3BlY3RlZC5cbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5ESVNQTEFZIHx8IHByb2Nlc3MuZW52LkRJU1BMQVkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZW52LkRJU1BMQVkgPSAnYXRvbS1naXRodWItcGxhY2Vob2xkZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgZW52LkFUT01fR0lUSFVCX09SSUdJTkFMX1BBVEggPSBwcm9jZXNzLmVudi5QQVRIIHx8ICcnO1xuICAgICAgICBlbnYuQVRPTV9HSVRIVUJfT1JJR0lOQUxfR0lUX0FTS1BBU1MgPSBwcm9jZXNzLmVudi5HSVRfQVNLUEFTUyB8fCAnJztcbiAgICAgICAgZW52LkFUT01fR0lUSFVCX09SSUdJTkFMX1NTSF9BU0tQQVNTID0gcHJvY2Vzcy5lbnYuU1NIX0FTS1BBU1MgfHwgJyc7XG4gICAgICAgIGVudi5BVE9NX0dJVEhVQl9PUklHSU5BTF9HSVRfU1NIX0NPTU1BTkQgPSBwcm9jZXNzLmVudi5HSVRfU1NIX0NPTU1BTkQgfHwgJyc7XG4gICAgICAgIGVudi5BVE9NX0dJVEhVQl9TUEVDX01PREUgPSBhdG9tLmluU3BlY01vZGUoKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICAgICAgZW52LlNTSF9BU0tQQVNTID0gbm9ybWFsaXplR2l0SGVscGVyUGF0aChhc2tQYXNzLmxhdW5jaGVyKTtcbiAgICAgICAgZW52LkdJVF9BU0tQQVNTID0gbm9ybWFsaXplR2l0SGVscGVyUGF0aChhc2tQYXNzLmxhdW5jaGVyKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgICAgICAgIGVudi5HSVRfU1NIX0NPTU1BTkQgPSBzc2hXcmFwcGVyLnNjcmlwdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnYuR0lUX1NTSF9DT01NQU5EID0gcHJvY2Vzcy5lbnYuR0lUX1NTSF9DT01NQU5EO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncy51bnNoaWZ0KCctYycsIGBjcmVkZW50aWFsLmhlbHBlcj0ke25vcm1hbGl6ZUdpdEhlbHBlclBhdGgoY3JlZGVudGlhbEhlbHBlci5sYXVuY2hlcil9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWFnbm9zdGljc0VuYWJsZWQpIHtcbiAgICAgICAgZW52LkdJVF9UUkFDRSA9ICd0cnVlJztcbiAgICAgICAgZW52LkdJVF9UUkFDRV9DVVJMID0gJ3RydWUnO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRpb25zID0ge2Vudn07XG5cbiAgICAgIGlmIChzdGRpbikge1xuICAgICAgICBvcHRpb25zLnN0ZGluID0gc3RkaW47XG4gICAgICAgIG9wdGlvbnMuc3RkaW5FbmNvZGluZyA9ICd1dGY4JztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52LlBSSU5UX0dJVF9USU1FUykge1xuICAgICAgICBjb25zb2xlLnRpbWUoYGdpdDoke2Zvcm1hdHRlZEFyZ3N9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB7cHJvbWlzZSwgY2FuY2VsfSA9IHRoaXMuZXhlY3V0ZUdpdENvbW1hbmQoYXJncywgb3B0aW9ucywgdGltaW5nTWFya2VyKTtcbiAgICAgICAgbGV0IGV4cGVjdENhbmNlbCA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2l0UHJvbXB0U2VydmVyKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5hZGQoZ2l0UHJvbXB0U2VydmVyLm9uRGlkQ2FuY2VsKGFzeW5jICh7aGFuZGxlclBpZH0pID0+IHtcbiAgICAgICAgICAgIGV4cGVjdENhbmNlbCA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCBjYW5jZWwoKTtcblxuICAgICAgICAgICAgLy8gT24gV2luZG93cywgdGhlIFNTSF9BU0tQQVNTIGhhbmRsZXIgaXMgZXhlY3V0ZWQgYXMgYSBub24tY2hpbGQgcHJvY2Vzcywgc28gdGhlIGJpblxcZ2l0LWFza3Bhc3MtYXRvbS5zaFxuICAgICAgICAgICAgLy8gcHJvY2VzcyBkb2VzIG5vdCB0ZXJtaW5hdGUgd2hlbiB0aGUgZ2l0IHByb2Nlc3MgaXMga2lsbGVkLlxuICAgICAgICAgICAgLy8gS2lsbCB0aGUgaGFuZGxlciBwcm9jZXNzICphZnRlciogdGhlIGdpdCBwcm9jZXNzIGhhcyBiZWVuIGtpbGxlZCB0byBlbnN1cmUgdGhhdCBnaXQgZG9lc24ndCBoYXZlIGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBmYWxsIGJhY2sgdG8gR0lUX0FTS1BBU1MgZnJvbSB0aGUgY3JlZGVudGlhbCBoYW5kbGVyLlxuICAgICAgICAgICAgcmVxdWlyZSgndHJlZS1raWxsJykoaGFuZGxlclBpZCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge3N0ZG91dCwgc3RkZXJyLCBleGl0Q29kZSwgdGltaW5nfSA9IGF3YWl0IHByb21pc2U7XG5cbiAgICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICAgIGNvbnN0IHtleGVjVGltZSwgc3Bhd25UaW1lLCBpcGNUaW1lfSA9IHRpbWluZztcbiAgICAgICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICB0aW1pbmdNYXJrZXIubWFyaygnbmV4dHRpY2snLCBub3cgLSBleGVjVGltZSAtIHNwYXduVGltZSAtIGlwY1RpbWUpO1xuICAgICAgICAgIHRpbWluZ01hcmtlci5tYXJrKCdleGVjdXRlJywgbm93IC0gZXhlY1RpbWUgLSBpcGNUaW1lKTtcbiAgICAgICAgICB0aW1pbmdNYXJrZXIubWFyaygnaXBjJywgbm93IC0gaXBjVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGltaW5nTWFya2VyLmZpbmFsaXplKCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5QUklOVF9HSVRfVElNRVMpIHtcbiAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoYGdpdDoke2Zvcm1hdHRlZEFyZ3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdpdFByb21wdFNlcnZlcikge1xuICAgICAgICAgIGdpdFByb21wdFNlcnZlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHRpb25zLmRpc3Bvc2UoKTtcblxuICAgICAgICBpZiAoZGlhZ25vc3RpY3NFbmFibGVkKSB7XG4gICAgICAgICAgaWYgKGhlYWRsZXNzKSB7XG4gICAgICAgICAgICBsZXQgc3VtbWFyeSA9IGBnaXQ6JHtmb3JtYXR0ZWRBcmdzfVxcbmA7XG4gICAgICAgICAgICBzdW1tYXJ5ICs9IGBleGl0IHN0YXR1czogJHtleGl0Q29kZX1cXG5gO1xuICAgICAgICAgICAgc3VtbWFyeSArPSAnc3Rkb3V0Oic7XG4gICAgICAgICAgICBpZiAoc3Rkb3V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBzdW1tYXJ5ICs9ICcgPGVtcHR5Plxcbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdW1tYXJ5ICs9IGBcXG4ke3N0ZG91dH1cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtbWFyeSArPSAnc3RkZXJyOic7XG4gICAgICAgICAgICBpZiAoc3RkZXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBzdW1tYXJ5ICs9ICcgPGVtcHR5Plxcbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdW1tYXJ5ICs9IGBcXG4ke3N0ZGVycn1cXG5gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdW1tYXJ5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyU3R5bGUgPSAnZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiBibHVlOyc7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoYGdpdDoke2Zvcm1hdHRlZEFyZ3N9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnJWNleGl0IHN0YXR1cyVjICVkJywgaGVhZGVyU3R5bGUsICdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogYmxhY2s7JywgZXhpdENvZGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJyVjc3Rkb3V0JywgaGVhZGVyU3R5bGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coc3Rkb3V0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCclY3N0ZGVycicsIGhlYWRlclN0eWxlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0ZGVycik7XG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXRDb2RlICE9PSAwICYmICFleHBlY3RDYW5jZWwpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgR2l0RXJyb3IoXG4gICAgICAgICAgICBgJHtmb3JtYXR0ZWRBcmdzfSBleGl0ZWQgd2l0aCBjb2RlICR7ZXhpdENvZGV9XFxuc3Rkb3V0OiAke3N0ZG91dH1cXG5zdGRlcnI6ICR7c3RkZXJyfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIuY29kZSA9IGV4aXRDb2RlO1xuICAgICAgICAgIGVyci5zdGRFcnIgPSBzdGRlcnI7XG4gICAgICAgICAgZXJyLnN0ZE91dCA9IHN0ZG91dDtcbiAgICAgICAgICBlcnIuY29tbWFuZCA9IGZvcm1hdHRlZEFyZ3M7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShzdGRvdXQpO1xuICAgICAgfSk7XG4gICAgfSwge3BhcmFsbGVsOiAhd3JpdGVPcGVyYXRpb259KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgfVxuXG4gIGV4ZWN1dGVHaXRDb21tYW5kKGFyZ3MsIG9wdGlvbnMsIG1hcmtlciA9IG51bGwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuQVRPTV9HSVRIVUJfSU5MSU5FX0dJVF9FWEVDIHx8ICFXb3JrZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuaXNSZWFkeSgpKSB7XG4gICAgICBtYXJrZXIgJiYgbWFya2VyLm1hcmsoJ25leHR0aWNrJyk7XG5cbiAgICAgIGxldCBjaGlsZFBpZDtcbiAgICAgIG9wdGlvbnMucHJvY2Vzc0NhbGxiYWNrID0gY2hpbGQgPT4ge1xuICAgICAgICBjaGlsZFBpZCA9IGNoaWxkLnBpZDtcblxuICAgICAgICBjaGlsZC5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzcGF3bmluZzogZ2l0ICR7YXJncy5qb2luKCcgJyl9IGluICR7dGhpcy53b3JraW5nRGlyfWApO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hpbGQuc3RkaW4ub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd3JpdGluZyB0byBzdGRpbjogZ2l0ICR7YXJncy5qb2luKCcgJyl9IGluICR7dGhpcy53b3JraW5nRGlyfVxcbiR7b3B0aW9ucy5zdGRpbn1gKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcHJvbWlzZSA9IEdpdFByb2Nlc3MuZXhlYyhhcmdzLCB0aGlzLndvcmtpbmdEaXIsIG9wdGlvbnMpO1xuICAgICAgbWFya2VyICYmIG1hcmtlci5tYXJrKCdleGVjdXRlJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlLFxuICAgICAgICBjYW5jZWw6ICgpID0+IGNoaWxkUGlkICYmIHJlcXVpcmUoJ3RyZWUta2lsbCcpKGNoaWxkUGlkKSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdvcmtlck1hbmFnZXIgPSB0aGlzLndvcmtlck1hbmFnZXIgfHwgV29ya2VyTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgcmV0dXJuIHdvcmtlck1hbmFnZXIucmVxdWVzdCh7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHdvcmtpbmdEaXI6IHRoaXMud29ya2luZ0RpcixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgZ2l0IGNvbW1hbmQgdGhhdCBtYXkgY3JlYXRlIGEgY29tbWl0LiBJZiB0aGUgY29tbWFuZCBmYWlscyBiZWNhdXNlIHRoZSBHUEcgYmluYXJ5IHdhcyBpbnZva2VkIGFuZCB1bmFibGVcbiAgICogdG8gYWNxdWlyZSBhIHBhc3NwaHJhc2UgKGJlY2F1c2UgdGhlIHBpbmVudHJ5IHByb2dyYW0gYXR0ZW1wdGVkIHRvIHVzZSBhIHR0eSksIHJldHJ5IHdpdGggYSBgR2l0UHJvbXB0U2VydmVyYC5cbiAgICovXG4gIGdwZ0V4ZWMoYXJncywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZ3BnQXJncyA9IFsnLWMnLCBgZ3BnLnByb2dyYW09JHtHUEdfSEVMUEVSX1BBVEh9YF0uY29uY2F0KGFyZ3MpO1xuICAgIHJldHVybiB0aGlzLmV4ZWMoZ3BnQXJncywgb3B0aW9ucykuY2F0Y2goZXJyID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gMTI4ICYmIC9ncGcgZmFpbGVkLy50ZXN0KGVyci5zdGRFcnIpICYmICFvcHRpb25zLnVzZUdpdFByb21wdFNlcnZlcikge1xuICAgICAgICAvLyBSZXRyeSB3aXRoIGEgR2l0UHJvbXB0U2VydmVyXG4gICAgICAgIG9wdGlvbnMudXNlR2l0UHJvbXB0U2VydmVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlYyhncGdBcmdzLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlc29sdmVEb3RHaXREaXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzU3RhdCh0aGlzLndvcmtpbmdEaXIpOyAvLyBmYWlscyBpZiBmb2xkZXIgZG9lc24ndCBleGlzdFxuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5leGVjKFsncmV2LXBhcnNlJywgJy0tcmVzb2x2ZS1naXQtZGlyJywgcGF0aC5qb2luKHRoaXMud29ya2luZ0RpciwgJy5naXQnKV0pO1xuICAgICAgY29uc3QgZG90R2l0RGlyID0gb3V0cHV0LnRyaW0oKTtcbiAgICAgIGlmIChwYXRoLmlzQWJzb2x1dGUoZG90R2l0RGlyKSkge1xuICAgICAgICByZXR1cm4gdG9OYXRpdmVQYXRoU2VwKGRvdEdpdERpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9OYXRpdmVQYXRoU2VwKHBhdGgucmVzb2x2ZShwYXRoLmpvaW4odGhpcy53b3JraW5nRGlyLCBkb3RHaXREaXIpKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjKFsnaW5pdCcsIHRoaXMud29ya2luZ0Rpcl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YWdpbmcvVW5zdGFnaW5nIGZpbGVzIGFuZCBwYXRjaGVzIGFuZCBjb21taXR0aW5nXG4gICAqL1xuICBzdGFnZUZpbGVzKHBhdGhzKSB7XG4gICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpOyB9XG4gICAgY29uc3QgYXJncyA9IFsnYWRkJ10uY29uY2F0KHBhdGhzLm1hcCh0b0dpdFBhdGhTZXApKTtcbiAgICByZXR1cm4gdGhpcy5leGVjKGFyZ3MsIHt3cml0ZU9wZXJhdGlvbjogdHJ1ZX0pO1xuICB9XG5cbiAgdW5zdGFnZUZpbGVzKHBhdGhzLCBjb21taXQgPSAnSEVBRCcpIHtcbiAgICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7IH1cbiAgICBjb25zdCBhcmdzID0gWydyZXNldCcsIGNvbW1pdCwgJy0tJ10uY29uY2F0KHBhdGhzLm1hcCh0b0dpdFBhdGhTZXApKTtcbiAgICByZXR1cm4gdGhpcy5leGVjKGFyZ3MsIHt3cml0ZU9wZXJhdGlvbjogdHJ1ZX0pO1xuICB9XG5cbiAgYXBwbHlQYXRjaChwYXRjaCwge2luZGV4fSA9IHt9KSB7XG4gICAgY29uc3QgYXJncyA9IFsnYXBwbHknLCAnLSddO1xuICAgIGlmIChpbmRleCkgeyBhcmdzLnNwbGljZSgxLCAwLCAnLS1jYWNoZWQnKTsgfVxuICAgIHJldHVybiB0aGlzLmV4ZWMoYXJncywge3N0ZGluOiBwYXRjaCwgd3JpdGVPcGVyYXRpb246IHRydWV9KTtcbiAgfVxuXG4gIGNvbW1pdChtZXNzYWdlLCB7YWxsb3dFbXB0eSwgYW1lbmR9ID0ge30pIHtcbiAgICBjb25zdCBhcmdzID0gWydjb21taXQnLCAnLW0nLCBtZXNzYWdlXTtcbiAgICBpZiAoYW1lbmQpIHsgYXJncy5wdXNoKCctLWFtZW5kJyk7IH1cbiAgICBpZiAoYWxsb3dFbXB0eSkgeyBhcmdzLnB1c2goJy0tYWxsb3ctZW1wdHknKTsgfVxuICAgIHJldHVybiB0aGlzLmdwZ0V4ZWMoYXJncywge3dyaXRlT3BlcmF0aW9uOiB0cnVlfSk7XG4gIH1cblxuICAvKipcbiAgICogRmlsZSBTdGF0dXMgYW5kIERpZmZzXG4gICAqL1xuICBhc3luYyBnZXRTdGF0dXNCdW5kbGUoKSB7XG4gICAgY29uc3QgYXJncyA9IFsnc3RhdHVzJywgJy0tcG9yY2VsYWluPXYyJywgJy0tYnJhbmNoJywgJy0tdW50cmFja2VkLWZpbGVzPWFsbCcsICctLWlnbm9yZS1zdWJtb2R1bGVzPWRpcnR5JywgJy16J107XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5leGVjKGFyZ3MpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBwYXJzZVN0YXR1cyhvdXRwdXQpO1xuXG4gICAgZm9yIChjb25zdCBlbnRyeVR5cGUgaW4gcmVzdWx0cykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0c1tlbnRyeVR5cGVdKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU5hdGl2ZVBhdGhTZXBGb3JFbnRyaWVzKHJlc3VsdHNbZW50cnlUeXBlXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICB1cGRhdGVOYXRpdmVQYXRoU2VwRm9yRW50cmllcyhlbnRyaWVzKSB7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIHdvdWxkIGF2b2lkIG11dGF0aW5nIHJlc3BvbnNlcyBmcm9tIG90aGVyIHBhY2thZ2UncyBBUElzLCBidXQgd2UgY29udHJvbFxuICAgICAgLy8gdGhlIGB3aGF0LXRoZS1zdGF0dXNgIG1vZHVsZSBhbmQga25vdyB0aGVyZSBhcmUgbm8gc2lkZSBlZmZlY3RzLlxuICAgICAgLy8gVGhpcyBpcyBhIGhvdCBjb2RlIHBhdGggYW5kIGJ5IG11dGF0aW5nIHdlIGF2b2lkIGNyZWF0aW5nIG5ldyBvYmplY3RzIHRoYXQgd2lsbCBqdXN0IGJlIEdDJ2VkXG4gICAgICBpZiAoZW50cnkuZmlsZVBhdGgpIHtcbiAgICAgICAgZW50cnkuZmlsZVBhdGggPSB0b05hdGl2ZVBhdGhTZXAoZW50cnkuZmlsZVBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKGVudHJ5Lm9yaWdGaWxlUGF0aCkge1xuICAgICAgICBlbnRyeS5vcmlnRmlsZVBhdGggPSB0b05hdGl2ZVBhdGhTZXAoZW50cnkub3JpZ0ZpbGVQYXRoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRpZmZGaWxlU3RhdHVzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFyZ3MgPSBbJ2RpZmYnLCAnLS1uYW1lLXN0YXR1cycsICctLW5vLXJlbmFtZXMnXTtcbiAgICBpZiAob3B0aW9ucy5zdGFnZWQpIHsgYXJncy5wdXNoKCctLXN0YWdlZCcpOyB9XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7IGFyZ3MucHVzaChvcHRpb25zLnRhcmdldCk7IH1cbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCB0aGlzLmV4ZWMoYXJncyk7XG5cbiAgICBjb25zdCBzdGF0dXNNYXAgPSB7XG4gICAgICBBOiAnYWRkZWQnLFxuICAgICAgTTogJ21vZGlmaWVkJyxcbiAgICAgIEQ6ICdkZWxldGVkJyxcbiAgICAgIFU6ICd1bm1lcmdlZCcsXG4gICAgfTtcblxuICAgIGNvbnN0IGZpbGVTdGF0dXNlcyA9IHt9O1xuICAgIG91dHB1dCAmJiBvdXRwdXQudHJpbSgpLnNwbGl0KExJTkVfRU5ESU5HX1JFR0VYKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgY29uc3QgW3N0YXR1cywgcmF3RmlsZVBhdGhdID0gbGluZS5zcGxpdCgnXFx0Jyk7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IHRvTmF0aXZlUGF0aFNlcChyYXdGaWxlUGF0aCk7XG4gICAgICBmaWxlU3RhdHVzZXNbZmlsZVBhdGhdID0gc3RhdHVzTWFwW3N0YXR1c107XG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLnN0YWdlZCkge1xuICAgICAgY29uc3QgdW50cmFja2VkID0gYXdhaXQgdGhpcy5nZXRVbnRyYWNrZWRGaWxlcygpO1xuICAgICAgdW50cmFja2VkLmZvckVhY2goZmlsZVBhdGggPT4geyBmaWxlU3RhdHVzZXNbZmlsZVBhdGhdID0gJ2FkZGVkJzsgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlU3RhdHVzZXM7XG4gIH1cblxuICBhc3luYyBnZXRVbnRyYWNrZWRGaWxlcygpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCB0aGlzLmV4ZWMoWydscy1maWxlcycsICctLW90aGVycycsICctLWV4Y2x1ZGUtc3RhbmRhcmQnXSk7XG4gICAgaWYgKG91dHB1dC50cmltKCkgPT09ICcnKSB7IHJldHVybiBbXTsgfVxuICAgIHJldHVybiBvdXRwdXQudHJpbSgpLnNwbGl0KExJTkVfRU5ESU5HX1JFR0VYKS5tYXAodG9OYXRpdmVQYXRoU2VwKTtcbiAgfVxuXG4gIGFzeW5jIGdldERpZmZGb3JGaWxlUGF0aChmaWxlUGF0aCwge3N0YWdlZCwgYmFzZUNvbW1pdH0gPSB7fSkge1xuICAgIGxldCBhcmdzID0gWydkaWZmJywgJy0tbm8tcHJlZml4JywgJy0tbm8tcmVuYW1lcycsICctLWRpZmYtZmlsdGVyPXUnXTtcbiAgICBpZiAoc3RhZ2VkKSB7IGFyZ3MucHVzaCgnLS1zdGFnZWQnKTsgfVxuICAgIGlmIChiYXNlQ29tbWl0KSB7IGFyZ3MucHVzaChiYXNlQ29tbWl0KTsgfVxuICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbJy0tJywgdG9HaXRQYXRoU2VwKGZpbGVQYXRoKV0pO1xuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuZXhlYyhhcmdzKTtcblxuICAgIGxldCByYXdEaWZmcyA9IFtdO1xuICAgIGlmIChvdXRwdXQpIHtcbiAgICAgIHJhd0RpZmZzID0gcGFyc2VEaWZmKG91dHB1dClcbiAgICAgICAgLmZpbHRlcihyYXdEaWZmID0+IHJhd0RpZmYuc3RhdHVzICE9PSAndW5tZXJnZWQnKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdEaWZmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByYXdEaWZmID0gcmF3RGlmZnNbaV07XG4gICAgICAgIGlmIChyYXdEaWZmLm9sZFBhdGgpIHtcbiAgICAgICAgICByYXdEaWZmLm9sZFBhdGggPSB0b05hdGl2ZVBhdGhTZXAocmF3RGlmZi5vbGRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmF3RGlmZi5uZXdQYXRoKSB7XG4gICAgICAgICAgcmF3RGlmZi5uZXdQYXRoID0gdG9OYXRpdmVQYXRoU2VwKHJhd0RpZmYubmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXN0YWdlZCAmJiAoYXdhaXQgdGhpcy5nZXRVbnRyYWNrZWRGaWxlcygpKS5pbmNsdWRlcyhmaWxlUGF0aCkpIHtcbiAgICAgIC8vIGFkZCB1bnRyYWNrZWQgZmlsZVxuICAgICAgY29uc3QgYWJzUGF0aCA9IHBhdGguam9pbih0aGlzLndvcmtpbmdEaXIsIGZpbGVQYXRoKTtcbiAgICAgIGNvbnN0IGV4ZWN1dGFibGUgPSBhd2FpdCBpc0ZpbGVFeGVjdXRhYmxlKGFic1BhdGgpO1xuICAgICAgY29uc3QgY29udGVudHMgPSBhd2FpdCByZWFkRmlsZShhYnNQYXRoKTtcbiAgICAgIGNvbnN0IGJpbmFyeSA9IGlzQmluYXJ5KGNvbnRlbnRzKTtcbiAgICAgIHJhd0RpZmZzLnB1c2goYnVpbGRBZGRlZEZpbGVQYXRjaChmaWxlUGF0aCwgYmluYXJ5ID8gbnVsbCA6IGNvbnRlbnRzLCBleGVjdXRhYmxlKSk7XG4gICAgfVxuICAgIGlmIChyYXdEaWZmcy5sZW5ndGggPiAxKSB7IHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgMCBvciAxIGRpZmZzIGZvciAke2ZpbGVQYXRofSBidXQgZ290ICR7cmF3RGlmZnMubGVuZ3RofWApOyB9XG4gICAgcmV0dXJuIHJhd0RpZmZzWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIE1pc2NlbGxhbmVvdXMgZ2V0dGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q29tbWl0KHJlZikge1xuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuZXhlYyhbJ2xvZycsICctLXByZXR0eT0lSCV4MDAlQiV4MDAnLCAnLS1uby1hYmJyZXYtY29tbWl0JywgJy0xJywgcmVmXSk7XG4gICAgY29uc3QgW3NoYSwgbWVzc2FnZV0gPSAob3V0cHV0KS5zcGxpdCgnXFwwJyk7XG4gICAgcmV0dXJuIHtzaGEsIG1lc3NhZ2U6IG1lc3NhZ2UudHJpbSgpLCB1bmJvcm5SZWY6IGZhbHNlfTtcbiAgfVxuXG4gIGFzeW5jIGdldEhlYWRDb21taXQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbW1pdCA9IGF3YWl0IHRoaXMuZ2V0Q29tbWl0KCdIRUFEJyk7XG4gICAgICBjb21taXQudW5ib3JuUmVmID0gZmFsc2U7XG4gICAgICByZXR1cm4gY29tbWl0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICgvdW5rbm93biByZXZpc2lvbi8udGVzdChlLnN0ZEVycikpIHtcbiAgICAgICAgcmV0dXJuIHtzaGE6ICcnLCBtZXNzYWdlOiAnJywgdW5ib3JuUmVmOiB0cnVlfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVhZEZpbGVGcm9tSW5kZXgoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjKFsnc2hvdycsIGA6JHt0b0dpdFBhdGhTZXAoZmlsZVBhdGgpfWBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZVxuICAgKi9cbiAgbWVyZ2UoYnJhbmNoTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdwZ0V4ZWMoWydtZXJnZScsIGJyYW5jaE5hbWVdLCB7d3JpdGVPcGVyYXRpb246IHRydWV9KTtcbiAgfVxuXG4gIGFzeW5jIGlzTWVyZ2luZyhkb3RHaXREaXIpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmVhZEZpbGUocGF0aC5qb2luKGRvdEdpdERpciwgJ01FUkdFX0hFQUQnKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYWJvcnRNZXJnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjKFsnbWVyZ2UnLCAnLS1hYm9ydCddLCB7d3JpdGVPcGVyYXRpb246IHRydWV9KTtcbiAgfVxuXG4gIGNoZWNrb3V0U2lkZShzaWRlLCBwYXRocykge1xuICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5leGVjKFsnY2hlY2tvdXQnLCBgLS0ke3NpZGV9YCwgLi4ucGF0aHMubWFwKHRvR2l0UGF0aFNlcCldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWJhc2VcbiAgICovXG4gIGFzeW5jIGlzUmViYXNpbmcoZG90R2l0RGlyKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGZpbGVFeGlzdHMocGF0aC5qb2luKGRvdEdpdERpciwgJ3JlYmFzZS1tZXJnZScpKSxcbiAgICAgIGZpbGVFeGlzdHMocGF0aC5qb2luKGRvdEdpdERpciwgJ3JlYmFzZS1hcHBseScpKSxcbiAgICBdKTtcbiAgICByZXR1cm4gcmVzdWx0cy5zb21lKHIgPT4gcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3RlIGludGVyYWN0aW9uc1xuICAgKi9cbiAgY2xvbmUocmVtb3RlVXJsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhcmdzID0gWydjbG9uZSddO1xuICAgIGlmIChvcHRpb25zLm5vTG9jYWwpIHsgYXJncy5wdXNoKCctLW5vLWxvY2FsJyk7IH1cbiAgICBpZiAob3B0aW9ucy5iYXJlKSB7IGFyZ3MucHVzaCgnLS1iYXJlJyk7IH1cbiAgICBpZiAob3B0aW9ucy5yZWN1cnNpdmUpIHsgYXJncy5wdXNoKCctLXJlY3Vyc2l2ZScpOyB9XG4gICAgYXJncy5wdXNoKHJlbW90ZVVybCwgdGhpcy53b3JraW5nRGlyKTtcblxuICAgIHJldHVybiB0aGlzLmV4ZWMoYXJncywge3dyaXRlT3BlcmF0aW9uOiB0cnVlfSk7XG4gIH1cblxuICBmZXRjaChyZW1vdGVOYW1lLCBicmFuY2hOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlYyhbJ2ZldGNoJywgcmVtb3RlTmFtZSwgYnJhbmNoTmFtZV0sIHt1c2VHaXRQcm9tcHRTZXJ2ZXI6IHRydWUsIHdyaXRlT3BlcmF0aW9uOiB0cnVlfSk7XG4gIH1cblxuICBwdWxsKHJlbW90ZU5hbWUsIGJyYW5jaE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ncGdFeGVjKFsncHVsbCcsIHJlbW90ZU5hbWUsIGJyYW5jaE5hbWVdLCB7dXNlR2l0UHJvbXB0U2VydmVyOiB0cnVlLCB3cml0ZU9wZXJhdGlvbjogdHJ1ZX0pO1xuICB9XG5cbiAgcHVzaChyZW1vdGVOYW1lLCBicmFuY2hOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhcmdzID0gWydwdXNoJywgcmVtb3RlTmFtZSB8fCAnb3JpZ2luJywgYnJhbmNoTmFtZV07XG4gICAgaWYgKG9wdGlvbnMuc2V0VXBzdHJlYW0pIHsgYXJncy5wdXNoKCctLXNldC11cHN0cmVhbScpOyB9XG4gICAgaWYgKG9wdGlvbnMuZm9yY2UpIHsgYXJncy5wdXNoKCctLWZvcmNlJyk7IH1cbiAgICByZXR1cm4gdGhpcy5leGVjKGFyZ3MsIHt1c2VHaXRQcm9tcHRTZXJ2ZXI6IHRydWUsIHdyaXRlT3BlcmF0aW9uOiB0cnVlfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBCcmFuY2hlc1xuICAgKi9cbiAgY2hlY2tvdXQoYnJhbmNoTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYXJncyA9IFsnY2hlY2tvdXQnXTtcbiAgICBpZiAob3B0aW9ucy5jcmVhdGVOZXcpIHsgYXJncy5wdXNoKCctYicpOyB9XG4gICAgcmV0dXJuIHRoaXMuZXhlYyhhcmdzLmNvbmNhdChicmFuY2hOYW1lKSwge3dyaXRlT3BlcmF0aW9uOiB0cnVlfSk7XG4gIH1cblxuICBjaGVja291dEZpbGVzKHBhdGhzLCByZXZpc2lvbikge1xuICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb25zdCBhcmdzID0gWydjaGVja291dCddO1xuICAgIGlmIChyZXZpc2lvbikgeyBhcmdzLnB1c2gocmV2aXNpb24pOyB9XG4gICAgcmV0dXJuIHRoaXMuZXhlYyhhcmdzLmNvbmNhdCgnLS0nLCBwYXRocy5tYXAodG9HaXRQYXRoU2VwKSksIHt3cml0ZU9wZXJhdGlvbjogdHJ1ZX0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0QnJhbmNoZXMoKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5leGVjKFsnZm9yLWVhY2gtcmVmJywgJy0tZm9ybWF0PSUocmVmbmFtZTpzaG9ydCknLCAncmVmcy9oZWFkcy8qKiddKTtcbiAgICByZXR1cm4gb3V0cHV0LnRyaW0oKS5zcGxpdChMSU5FX0VORElOR19SRUdFWCk7XG4gIH1cblxuICBhc3luYyBkZXNjcmliZUhlYWQoKSB7XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmV4ZWMoWydkZXNjcmliZScsICctLWNvbnRhaW5zJywgJy0tYWxsJywgJy0tYWx3YXlzJywgJ0hFQUQnXSkpLnRyaW0oKTtcbiAgfVxuXG4gIGFzeW5jIGdldENvbmZpZyhvcHRpb24sIHtsb2NhbH0gPSB7fSkge1xuICAgIGxldCBvdXRwdXQ7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBhcmdzID0gWydjb25maWcnXTtcbiAgICAgIGlmIChsb2NhbCkgeyBhcmdzLnB1c2goJy0tbG9jYWwnKTsgfVxuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KG9wdGlvbik7XG4gICAgICBvdXRwdXQgPSBhd2FpdCB0aGlzLmV4ZWMoYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09IDEpIHtcbiAgICAgICAgLy8gTm8gbWF0Y2hpbmcgY29uZmlnIGZvdW5kXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQudHJpbSgpO1xuICB9XG5cbiAgc2V0Q29uZmlnKG9wdGlvbiwgdmFsdWUsIHtyZXBsYWNlQWxsfSA9IHt9KSB7XG4gICAgbGV0IGFyZ3MgPSBbJ2NvbmZpZyddO1xuICAgIGlmIChyZXBsYWNlQWxsKSB7IGFyZ3MucHVzaCgnLS1yZXBsYWNlLWFsbCcpOyB9XG4gICAgYXJncyA9IGFyZ3MuY29uY2F0KG9wdGlvbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmV4ZWMoYXJncywge3dyaXRlT3BlcmF0aW9uOiB0cnVlfSk7XG4gIH1cblxuICB1bnNldENvbmZpZyhvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5leGVjKFsnY29uZmlnJywgJy0tdW5zZXQnLCBvcHRpb25dLCB7d3JpdGVPcGVyYXRpb246IHRydWV9KTtcbiAgfVxuXG4gIGFzeW5jIGdldFJlbW90ZXMoKSB7XG4gICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlnKFsnLS1nZXQtcmVnZXhwJywgJ15yZW1vdGVcXFxcLi4qXFxcXC51cmwkJ10sIHtsb2NhbDogdHJ1ZX0pO1xuICAgIGlmIChvdXRwdXQpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC50cmltKCk7XG4gICAgICBpZiAoIW91dHB1dC5sZW5ndGgpIHsgcmV0dXJuIFtdOyB9XG4gICAgICByZXR1cm4gb3V0cHV0LnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCgvXnJlbW90ZVxcLiguKilcXC51cmwgKC4qKSQvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBtYXRjaFsxXSxcbiAgICAgICAgICB1cmw6IG1hdGNoWzJdLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhdGVCbG9iKHtmaWxlUGF0aCwgc3RkaW59ID0ge30pIHtcbiAgICBsZXQgb3V0cHV0O1xuICAgIGlmIChmaWxlUGF0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0cHV0ID0gKGF3YWl0IHRoaXMuZXhlYyhbJ2hhc2gtb2JqZWN0JywgJy13JywgZmlsZVBhdGhdLCB7d3JpdGVPcGVyYXRpb246IHRydWV9KSkudHJpbSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5zdGRFcnIgJiYgZS5zdGRFcnIubWF0Y2goL2ZhdGFsOiBDYW5ub3Qgb3BlbiAuKjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeS8pKSB7XG4gICAgICAgICAgb3V0cHV0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGRpbikge1xuICAgICAgb3V0cHV0ID0gKGF3YWl0IHRoaXMuZXhlYyhbJ2hhc2gtb2JqZWN0JywgJy13JywgJy0tc3RkaW4nXSwge3N0ZGluLCB3cml0ZU9wZXJhdGlvbjogdHJ1ZX0pKS50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzdXBwbHkgZmlsZSBwYXRoIG9yIHN0ZGluJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBhc3luYyBleHBhbmRCbG9iVG9GaWxlKGFic0ZpbGVQYXRoLCBzaGEpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCB0aGlzLmV4ZWMoWydjYXQtZmlsZScsICctcCcsIHNoYV0pO1xuICAgIGF3YWl0IHdyaXRlRmlsZShhYnNGaWxlUGF0aCwgb3V0cHV0KTtcbiAgICByZXR1cm4gYWJzRmlsZVBhdGg7XG4gIH1cblxuICBhc3luYyBnZXRCbG9iQ29udGVudHMoc2hhKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlYyhbJ2NhdC1maWxlJywgJy1wJywgc2hhXSk7XG4gIH1cblxuICBhc3luYyBtZXJnZUZpbGUob3Vyc1BhdGgsIGNvbW1vbkJhc2VQYXRoLCB0aGVpcnNQYXRoLCByZXN1bHRQYXRoKSB7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgICdtZXJnZS1maWxlJywgJy1wJywgb3Vyc1BhdGgsIGNvbW1vbkJhc2VQYXRoLCB0aGVpcnNQYXRoLFxuICAgICAgJy1MJywgJ2N1cnJlbnQnLCAnLUwnLCAnYWZ0ZXIgZGlzY2FyZCcsICctTCcsICdiZWZvcmUgZGlzY2FyZCcsXG4gICAgXTtcbiAgICBsZXQgb3V0cHV0O1xuICAgIGxldCBjb25mbGljdCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQgPSBhd2FpdCB0aGlzLmV4ZWMoYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBHaXRFcnJvciAmJiBlLmNvZGUgPT09IDEpIHtcbiAgICAgICAgb3V0cHV0ID0gZS5zdGRPdXQ7XG4gICAgICAgIGNvbmZsaWN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW50ZXJwcmV0IGEgcmVsYXRpdmUgcmVzdWx0UGF0aCBhcyByZWxhdGl2ZSB0byB0aGUgcmVwb3NpdG9yeSB3b3JraW5nIGRpcmVjdG9yeSBmb3IgY29uc2lzdGVuY3kgd2l0aCB0aGVcbiAgICAvLyBvdGhlciBhcmd1bWVudHMuXG4gICAgY29uc3QgcmVzb2x2ZWRSZXN1bHRQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMud29ya2luZ0RpciwgcmVzdWx0UGF0aCk7XG4gICAgYXdhaXQgd3JpdGVGaWxlKHJlc29sdmVkUmVzdWx0UGF0aCwgb3V0cHV0KTtcblxuICAgIHJldHVybiB7ZmlsZVBhdGg6IG91cnNQYXRoLCByZXN1bHRQYXRoLCBjb25mbGljdH07XG4gIH1cblxuICBhc3luYyB3cml0ZU1lcmdlQ29uZmxpY3RUb0luZGV4KGZpbGVQYXRoLCBjb21tb25CYXNlU2hhLCBvdXJzU2hhLCB0aGVpcnNTaGEpIHtcbiAgICBjb25zdCBnaXRGaWxlUGF0aCA9IHRvR2l0UGF0aFNlcChmaWxlUGF0aCk7XG4gICAgY29uc3QgZmlsZU1vZGUgPSBhd2FpdCB0aGlzLmdldEZpbGVNb2RlKGZpbGVQYXRoKTtcbiAgICBsZXQgaW5kZXhJbmZvID0gYDAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxcdCR7Z2l0RmlsZVBhdGh9XFxuYDtcbiAgICBpZiAoY29tbW9uQmFzZVNoYSkgeyBpbmRleEluZm8gKz0gYCR7ZmlsZU1vZGV9ICR7Y29tbW9uQmFzZVNoYX0gMVxcdCR7Z2l0RmlsZVBhdGh9XFxuYDsgfVxuICAgIGlmIChvdXJzU2hhKSB7IGluZGV4SW5mbyArPSBgJHtmaWxlTW9kZX0gJHtvdXJzU2hhfSAyXFx0JHtnaXRGaWxlUGF0aH1cXG5gOyB9XG4gICAgaWYgKHRoZWlyc1NoYSkgeyBpbmRleEluZm8gKz0gYCR7ZmlsZU1vZGV9ICR7dGhlaXJzU2hhfSAzXFx0JHtnaXRGaWxlUGF0aH1cXG5gOyB9XG4gICAgcmV0dXJuIHRoaXMuZXhlYyhbJ3VwZGF0ZS1pbmRleCcsICctLWluZGV4LWluZm8nXSwge3N0ZGluOiBpbmRleEluZm8sIHdyaXRlT3BlcmF0aW9uOiB0cnVlfSk7XG4gIH1cblxuICBhc3luYyBnZXRGaWxlTW9kZShmaWxlUGF0aCkge1xuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuZXhlYyhbJ2xzLWZpbGVzJywgJy0tc3RhZ2UnLCAnLS0nLCB0b0dpdFBhdGhTZXAoZmlsZVBhdGgpXSk7XG4gICAgaWYgKG91dHB1dCkge1xuICAgICAgcmV0dXJuIG91dHB1dC5zbGljZSgwLCA2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXhlY3V0YWJsZSA9IGF3YWl0IGlzRmlsZUV4ZWN1dGFibGUocGF0aC5qb2luKHRoaXMud29ya2luZ0RpciwgZmlsZVBhdGgpKTtcbiAgICAgIHJldHVybiBleGVjdXRhYmxlID8gJzEwMDc1NScgOiAnMTAwNjQ0JztcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY29tbWFuZFF1ZXVlLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEFkZGVkRmlsZVBhdGNoKGZpbGVQYXRoLCBjb250ZW50cywgZXhlY3V0YWJsZSkge1xuICBjb25zdCBodW5rcyA9IFtdO1xuICBpZiAoY29udGVudHMpIHtcbiAgICBjb25zdCBub05ld0xpbmUgPSBjb250ZW50c1tjb250ZW50cy5sZW5ndGggLSAxXSAhPT0gJ1xcbic7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50cy50cmltKCkuc3BsaXQoTElORV9FTkRJTkdfUkVHRVgpLm1hcChsaW5lID0+IGArJHtsaW5lfWApO1xuICAgIGlmIChub05ld0xpbmUpIHsgbGluZXMucHVzaCgnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7IH1cbiAgICBodW5rcy5wdXNoKHtcbiAgICAgIGxpbmVzLFxuICAgICAgb2xkU3RhcnRMaW5lOiAwLFxuICAgICAgb2xkTGluZUNvdW50OiAwLFxuICAgICAgbmV3U3RhcnRMaW5lOiAxLFxuICAgICAgaGVhZGluZzogJycsXG4gICAgICBuZXdMaW5lQ291bnQ6IG5vTmV3TGluZSA/IGxpbmVzLmxlbmd0aCAtIDEgOiBsaW5lcy5sZW5ndGgsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvbGRQYXRoOiBudWxsLFxuICAgIG5ld1BhdGg6IHRvTmF0aXZlUGF0aFNlcChmaWxlUGF0aCksXG4gICAgb2xkTW9kZTogbnVsbCxcbiAgICBuZXdNb2RlOiBleGVjdXRhYmxlID8gJzEwMDc1NScgOiAnMTAwNjQ0JyxcbiAgICBzdGF0dXM6ICdhZGRlZCcsXG4gICAgaHVua3MsXG4gIH07XG59XG4iXX0=